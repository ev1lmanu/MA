\chapter{Racket}
Racket ist ein Dialekt von Lisp, der auf Scheme basiert\cite{racketguide-dialects}. Es ist jedoch keine rein funktionale Sprache, sondern unterstützt verschiedene Lisp-Dialekte und  Programmierparadigmen. 
%Damit gibt Racket Programmierern und Forschern die Werkzeuge, die sie benötigen, um neue Sprachen zu erkunden und zu entwickeln\cite{racketguide-dialects} und wird beispielsweise auch an der Universität Hamburg in der Forschung genutzt.

% TODO ggf. verschieben
Racket wird in der Softwareentwicklungslehre genutzt, da es im Gegensatz zu Common Lisp sehr einteigerfreundlich ist. Die Veranstaltungsteilnehmer lernen zum ersten Mal eine funktionale Sprache kennen und sollen einen möglichst einfachen Einstieg erhalten, mit übersichtlicher Syntax und einer plattformunabhängigen Entwicklungsumgebung, die vergleichbare Fehlermeldungen liefert.

In Common Lisp wird die Syntax schnell sehr komplex und ist zudem abhängig von der Implementierung (teilweise sogar kostenpflichtig). Common Lisp hat zwei verschiedene Paketsysteme mit tausenden von Paketen, was ein schnelles Zurechtfinden in der Sprache nicht unbedingt begünstigt. Es gibt keine dedizierte grafische Oberfläche, da Common Lisp für die Integration in Emacs, Vim etc. ausgelegt ist. Das würde bedeuten, dass Veranstaltungsteilnehmer sich erst einmal mit der Integration der Sprache in den Editor ihrer Wahl beschäftigen müssten, bevor sie überhaupt eine Zeile Code schreiben können. Nicht alle Interpreter von Common Lisp werden auch für alle Betriebssysteme gewartet, wie zum Beispiel SBCL, der zwar frei und gut ist, aber unter Windows nur gelegentlich gepflegt wird. Das macht es extrem schwer die Ursache von Fehlern zu erkennen, da immer auch das Betriebssystem bedacht werden muss. Zudem ist eine grafische Ausgabe nicht vorgesehen. %TODO was war mit grafischer Ausgabe gemeint?

Um Common Lisp zu lernen, wurde daher Scheme entwickelt. Analog zu BlueJ, einer Entwicklungsumgebung für das Lernen von objektorientierter Programmierung in Java, war DrScheme das Einsteigertool zu Common Lisp. Irgendwann wurde aus Scheme Racket. Racket bildet einen guten Kompromiss für die Lehre, da es einen einfachen Einstieg in die Welt von Common Lisp bietet.
%----------------------

Die Syntax von Racket ist sehr ähnlich zu Common Lisp. Ausdrücke werden geklammert, Kommentare mit einem Semikolon eingeleitet. Einige Standardfunktionen haben leicht abgewandelte Namen. So werden in Racket beispielsweise Variablen mit \texttt{define} definiert anstelle von \texttt{defun}, Prädike enden auf \texttt{?} (zum Beispiel \texttt{equal?}) und Methoden, die Variablen oder Objekte verändern auf \texttt{!} (zum Beispiel \texttt{set!}). Einer der größeren Unterschiede liegt in der Art, wie Makros definiert werden, aber darauf wird im Kapitel TODO %TODO
näher eingegangen.

Unter anderem unterstützt Racket objektorientierte Programmierung, und das auf zwei verschiedene Arten.  Racket an sich ist eine vollständige objektorientierte Programmiersprache. Racket-Klassen sind sehr ähnlich zu Klassen in Java, C\# oder den meisten objektorientierten Programmiersprachen\cite{neu-edu2}. Ein Programm kann Klassen definieren, instanziieren, mit den erzeugten Objekten interagieren und Klassen erweitern. Besonders ist, dass Klassen auch wie Funktionswerte behandelt werden können. Es ist möglich, eine Klasse zur Laufzeit zu erweitern, eine Klasse an eine Funktion zu geben oder in einer Datenstruktur zu speichern und anschließend abzufragen\cite{neu-edu}. 

Zusätzlich bietet Racket eine Implementation des Common Lisp Object Systems (CLOS) in Form der Erweiterung Swindle. Im Gegensatz zum eingebauten Objektsystem von Racket bietet CLOS Features wie Mehrfachvererbung, Methodenkombination oder Vor- und Nachmethoden. Durch die Implementation als Metaobject-Protocol bietet es dem Programmierer zudem viel Freiheit bei der Erweiterung und Veränderung der Repräsentation von Klassen und Objekten.

Um ein Gefühl für die beiden Objektsysteme zu bekommen, soll zunächst betrachtet werden, wie sie benutzt werden können. Das geschieht in den folgenden zwei Abschnitten anhand eines einfachen Beispiels. Anschließend wird ein Blick auf die Implementation geworfen. Die Autoren des Buches ``The Art of the Metaobject Protocol''\cite{amop} haben einen sehr treffenden Vergleich dafür gewählt: Stellt man sich vor, ein objektorientiertes Programm sei ein Theaterstück, so betrachten wir zunächst das, was auf der Bühne (onstage) geschieht, bevor wir einen Blick hinter die Kulissen (backstage) werfen.

Der Fokus liegt dabei stark auf Features, die direkt oder indirekt mit Mehrfachvererbung zu tun haben. Natürlich bieten sowohl das Objektsystem von Racket als auch CLOS noch viele weitere nützliche Features; auf diese wird jedoch im Rahmen dieser Arbeit nicht weiter eingegangen.

Die Installation von Racket beinhaltet eine integrierte Enwicklungsumgebung namens DrRacket. Für das Syntaxhighlighting der Quelltextbeispiele in dieser Arbeit wurde das Standard-Farbschema von DrRacket verwendet. Anfragen an die Interaktionskonsole wurden mit \texttt{>} markiert und das Ergebnis in der Zeile darunter aufgeführt. 