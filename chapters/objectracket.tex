\section{Das Objektsystem von Racket}
Als Grundlage für dieses Kapitel dient die Racket-Dokumentation \cite{racketguide-classes} und -Referenz \cite{racketref-classes} für Klassen und Objekte.

Racket ist eine Multipurpose-Sprache und erlaubt die Auswahl der Syntax auf Sprachebene. Eine einzelne Codezeile bestimmt die Sprache eines Moduls, also beispielsweise, ob die Funktionen vorgezogen ausgewertet werden (\texttt{\#lang racket}) oder verzögert (\texttt{\#lang lazy}). Da das Objektsystem in die Sprache Racket integiert ist, kann man es direkt in jedem Racket-Modul verwenden.

Die wichtigsten Werkzeuge, die man als Programmierer in einer objektorientierten Sprache benötigt, sind das Definieren von Klassen, Feldern und Funktionen, sowie das Erzeugen von Objekten. Auf diese soll deshalb im Folgenden kurz eingegangen werden, bevor wir dazu kommen, welche Möglichkeiten es in Bezug auf Mehrfachvererbung im Objektsystem von Racket bereits gibt.

Alle Code-Beispiele befinden sich auch auf der beiligenden CD und sind noch einmal zusammenhängend in Anhang \ref{or-example} aufgeführt. 

\subsection{Einfache Klassen}

Eine Klasse wird in Racket durch das Schlüsselwort \texttt{class} definiert. Bei der Definition einer Klasse muss die Superklasse angegeben werden. Falls die Klasse keine (andere) Superklasse hat, wird \texttt{object\%} angegeben, die eingebaute Wurzelklasse. Per Konvention sollen Klassennamen in Racket auf \% enden, bei den folgenden Beispielen wird jedoch darauf verzichtet, um sie später leichter mit CLOS vergleichen zu können. Nach der Superklasse können noch beliebige Klassenoptionen, Felder oder Methoden definiert werden. An einer beliebigen Stelle im Rumpf der Klasse muss jedoch mit \texttt{super-new} der Konstruktor der Oberklasse aufgerufen werden. Eine minimale Klassendefinition sieht damit folgendermaßen aus:

\begin{lstlisting}
(class object% (super-new))
\end{lstlisting}

Als Rückgabewert erhält man ein Klassenobjekt und kann dieses für den späteren Zugriff einer Variablen zuweisen. Wir können die leere Klasse beispielsweise Thing nennen.

\begin{lstlisting}
(define Thing (class object% (super-new)))
\end{lstlisting}

Objekte von Klassen lassen sich mit den Schlüsselwörtern \texttt{new}, \texttt{make-object} und \texttt{instantiate} erzeugen, je nachdem ob Initialisierungsargumente durch Name, Position oder auf beide Arten angegeben werden sollen. Wir verwenden im Folgenden \texttt{new} und initialisieren damit Felder durch Angabe des Namens:

\begin{lstlisting}
(new Thing)
\end{lstlisting}

Felder lassen sich mit \texttt{init-field} oder \texttt{field} deklarieren, je nachdem, ob es möglich sein soll sie bei der Objekterzeugung zu initialisieren oder nicht. Wir können beispielsweise zu der Klasse Thing ein Feld hinzufügen, das eine Beschreibung des Objekts enthält:

\begin{lstlisting}
(define Thing (class object% (super-new)
                (init-field [name "a Thing"])))
\end{lstlisting}

Auf die Felder kann man dann mit \texttt{get-field} beziehungsweise \texttt{set-field!} zugreifen. 

\begin{lstlisting}
> (get-field name (new Thing))
\end{lstlisting}
{\routput {\qq}a Thing{\qq}}

\begin{lstlisting}
(define bob (new Thing [name "Bob"]))

> (get-field name bob)
\end{lstlisting}
{\routput {\qq}Bob{\qq}}

\begin{lstlisting}
> (set-field name bob "not Bob")
> (get-field name bob)
\end{lstlisting}
{\routput {\qq}not Bob{\qq}}

Für Methoden gibt es, je nach Art und Sichtbarkeit, unter anderem die Schlüsselwörter \texttt{define/public}, \texttt{define/private} und \texttt{define/override}. Wir können für die Klasse Thing eine Methode \texttt{who-are-you?} definieren, die einen beschreibenden Text für das Objekt ausgibt:

\begin{lstlisting}
(define Thing (class object% (super-new)
                (init-field [name "a Thing"])
                (define/public (who-are-you?) 
                  (string-append "I am " name "!"))))
\end{lstlisting}

Die Methode lässt sich anschließend mittels \texttt{send} aufrufen.

\begin{lstlisting}
(send (new Thing) who-are-you?)
\end{lstlisting}
{\routput {\qq}I am a Thing!{\qq}}

\begin{lstlisting}
(send bob who-are-you?)
\end{lstlisting}
{\routput {\qq}I am not Bob!{\qq}}

Attribute, die keinen Defaultwert haben, müssen bei der Initialisierung angegeben werden. Da das Attribut \texttt{name} den Wert  \texttt{{\qq}a Thing{\qq}} als Defaultwert hat, ist eine Angabe bei der Objekterzeugung optional. 

Um von Thing zu erben, müssen wir in der Klassendefinition lediglich Thing statt \texttt{object\%} als Superklasse angeben. So können wir beispielweise eine Klasse Element definieren, die von Thing erbt:

\begin{lstlisting}
(define Element (class Thing (super-new)
                  (init-field [attr 'water])
                  (define/public (hot?) (equal? attr 'fire))))
\end{lstlisting}

Element definiert auch noch ein eigenes Feld sowie eine Methode, damit wir später das Verhalten bei der Klasse betrachten können, die von Element erbt. Objekte von Element haben sowohl Zugriff auf die neu definierten Features als auch auf die geerbten:

\begin{lstlisting}
> (send (new Element) who-are-you?)
\end{lstlisting}
{\routput {\qq}I am a Thing!\qq}

\begin{lstlisting}
(define elem (new Element "Fire" 'fire))
> (send elem who-are-you?)
\end{lstlisting} 
{\routput {\qq}I am Fire!\qq}
\begin{lstlisting}
> (send elem hot?)
\end{lstlisting} 
{\routput{\#t}}

Element kann auch das geerbe Verhalten von Thing ändern. Wenn wir zum Beispiel den Defaultwert von \texttt{name} in Element ändern wollen, können wir den Wert per Hand mit \texttt{init} initialisieren und den Wert dann an die Superklasse übergeben:

\begin{lstlisting}
(define Element (class Thing 
                  (init [name "an Element"])  ; !
                  (super-new [name name])     ; !
                  (init-field [attr 'water])
                  (define/public (hot?) (equal? attr 'fire))))
  
(send (new Element) who-are-you?)
\end{lstlisting}
{\routput {\qq}I am an Element!\qq}

Analog können geerbte Methoden mit \texttt{define/override} überschrieben werden. Die Methode der Superklasse lässt sich mit \texttt{super} aufrufen:

\begin{lstlisting}
(define Element (class Thing 
                  ...
                  (define/override (who-are-you?)
                    (string-append (super who-are-you?)
                                   (if (hot?) " And I am hot!" "")))))
                                   
> (send (new Element) who-are-you?)
\end{lstlisting}
{\routput {\qq}I am an Element!\qq}

\begin{lstlisting}
> (send elem who-are-you?)
\end{lstlisting}
{\routput {\qq}I am Fire! And I am hot!\qq}

Es gibt jedoch eine Einschränkung: Features der Oberklasse sind innerhalb der Klassendefinition von Element jedoch nicht ohne weiteres sichtbar: 

\begin{lstlisting}
(define Element (class Thing 
                  ...
                  (define/public (get-name) name)))
\end{lstlisting}
{\rerror class: cannot use non-field init variable in a method in: name}

Wir haben Felder und Methoden der Superklasse bisher immer innerhalb eines \texttt{super}-Aufrufs benutzt. Falls wir jedoch direkten Zugriff auf den Wert von \texttt{name} brauchen, so müssen wir das explizit durch \texttt{inherit-field} (oder \texttt{inherit} für Methoden) angeben:

\begin{lstlisting}
(define Element (class Thing 
                  (init [name "an Element"])
                  (super-new [name name])
                  ...
                  (inherit-field name)
                  (define/public (get-name) name)))
\end{lstlisting}
{\rerror  class: duplicate declared identifier in: name}

Wir erhalten immer noch einen Fehler, denn nun haben wir zwei Deklarationen für das Feld \texttt{name}: durch \texttt{init} und durch \texttt{inherit-field}. Wir müssen uns entscheiden, eins von beiden umzubennennen. Ein Umbenennen des Initialisierungs-Paramters würde bedeuten, dass sich die Syntax der Objekterzeugung ändert, das wollen wir vermeiden. Es wird also das geerbte Feld umbenannt:

\begin{lstlisting}
(define Element (class Thing 
                  ...
                  (inherit-field [newname name])
                  (define/public (get-name) newname)))
\end{lstlisting}

Nun gibt es keinen Fehler mehr und wir können die Methode aufrufen:

\begin{lstlisting}
> (send (new Element) get-name)
\end{lstlisting}
{\routput {\qq}an Element\qq}

\subsection{Mehrfachvererbung in Racket}
\label{mixins}
Zuvor wurde behauptet, mit Racket könne man keine Mehrfachvererbung modellieren. Tatsächlich gibt es zwei Arten von Klassen in Racket, deren Verhalten auf den ersten Blick wie Mehrfachvererbung aussieht: Mixins und Traits. Es werden deshalb beide kurz vorgestellt, um aufzuzeigen, welche Probleme und Grenzen sie haben.

Dafür verwenden wir unsere vorher definierte Klasse Thing, eine vereinfachte Version von Element, sowie die folgende Klasse Animal, die ebenfalls von Thing erbt:

\begin{lstlisting}
(define Element (class Thing 
                  (init [name "an Element"])
                  (super-new [name name])
                  (init-field [attr 'water])
                  (define/public (hot?) (equal? attr 'fire)))

(define Animal (class Thing
                 (init [name "an Animal"])
                 (super-new [name name])
                 (init-field [size 'small])))
\end{lstlisting}

Animal redefiniert ebenfalls den Defaultwert für den Namen und besitzt außerdem noch ein eigenes Feld \texttt{size} für die Größe.

Animal und Element haben sowohl gemeinsame als auch unterschiedliche Felder und Methoden. Wir wollen versuchen, die Felder und Methoden aus beiden in einer neuen Klasse namens Pokemon zu vereinigen. 

% Das ginge natürlich ganz simpel, indem eine der beiden Klassen in Pokemon umbenannt wird und von der anderen erbt, deshalb wollen wir außerdem fordern, dass beide Klassen auch einzeln verwendet können. 


\subsubsection{Mixins}
Die Auswertung eines \texttt{class}-Aufrufs gibt uns ein Klassenobjekt zurück. Es möglich, dieses als Parameter an Funktionen oder andere Klassen zu übergeben oder auch als Rückgabewert eines Funktionsaufrufs zu definieren. Wir könnten uns beispielsweise eine Methode \texttt{generate-subclass} definieren, die eine Klasse als Parameter erhält und eine Subklasse von dieser erzeugt. Dafür muss sie den Parameter nur als Superklasse in einer Klassendefinition verwenden:

\begin{lstlisting}
(define (generate-subclass superclass)
  (class superclass (super-new)))
\end{lstlisting} 

Das ist noch keine sonderlich spannende Subklasse, da sie sich genauso verhält wie die angegebene Superklasse.
% aber wir können uns von ihrer Funktionalität überzeugen. Nehmen wir beispielsweise eine Subklasse der Klasse Element:
% 
% \begin{lstlisting}
% > (generate-subclass Element) 
% \end{lstlisting}
% {\routput \#<class:...>}
% 
% Dann erhalten wir das gleiche Verhalten wie für Objekte der Klasse Element:
% 
% \begin{lstlisting}
% > (new (generate-subclass Element))
% \end{lstlisting}
% {\routput (object:...)}
% 
% \begin{lstlisting}
% > (send (new (generate-subclass Element)) get-attr)
% \end{lstlisting}
% {\rsymbol water}
% 
Nun könnte man in der in \texttt{generate-} \texttt{subclass} definierten Klasse natürlich auch noch weitere Felder und Methoden hinzufügen. Die Klasse fügt dann Verhalten zu einer bestehenden, aber noch unbekannten Klasse hinzu. Erst beim Methodenaufruf wird der Platzhalter mit einer tatsächlichen Superklasse gefüllt. Eine solche Klasse wird in Racket Mixin genannt und als Platzhalter für die Superklasse wird per Konvention \texttt{\%} genommen:

\begin{lstlisting}
(define (a-mixin %)
  (class % (super-new)
    ; neues Verhalten
    ))
\end{lstlisting}

Falls wir das Verhalten beider Klassen Element und Animal vereinen wollen, so könnten wir eine von ihnen, oder beide, als Mixin definieren. Beide Klassen als Mixin zu definieren kommt am nächsten an unsere Idee von Mehrfachvererbung:

\begin{lstlisting}
(define (Element-Mixin %)
  (class % 
    (init [name "an Element"])
    (super-new [name name])
    (init-field [attr 'water])
    (define/public (hot?) (equal? attr 'fire))))

(define (Animal-Mixin %)
  (class %
  (init [name "an Animal"])
    (super-new [name name])
    (init-field [gender 'male])))
\end{lstlisting}

Und aus diesen könnten wir uns dann alle drei Klassen Element, Animal und Pokemon erzeugen:
\begin{lstlisting}
(define Element (Element-Mixin Thing))

(define Animal (Animal-Mixin Thing))
 
(define Pokemon (Element-Mixin (Animal-Mixin Thing)))
\end{lstlisting}

Es fällt auf, dass die zwei Mixins nicht gleichwertig sind; wir müssen uns entscheiden, welches von beiden wir zuerst anwenden. Genau genommen passiert hier auch keine Mehrfachvererbung, sondern zweifache Einfachvererbung -- mit dem Vorteil jedoch, dass wir die zwei Klassen auch unabhängig voneinander verwenden können. Die Hierarchie sieht also wie folgt aus:

\texttt{Pokemon $\rightarrow$ Element $\rightarrow$ Animal $\rightarrow$ Thing $\rightarrow$ object\%}

Element und Animal verhalten sich genauso wie zuvor:

\begin{lstlisting}
(send (new Animal) who-are-you?)
\end{lstlisting}
{\routput {\qq}I am an Animal!\qq}

\begin{lstlisting}
(get-field size (new Animal))
\end{lstlisting}
{\rsymbol small}

\begin{lstlisting}
(send (new Element) who-are-you?)
\end{lstlisting}
{\routput {\qq}I am an Element!\qq}

\begin{lstlisting}
(define elem (new Element [attr 'fire] [name "Fire"]))
> (send elem who-are-you?)
\end{lstlisting} 
{\routput {\qq}I am Fire!\qq}

\begin{lstlisting}
> (send elem hot?)
\end{lstlisting} 
{\routput \#t}

Zusätzlich können wir uns nun auch ein Pokemon definieren, das alle drei Eigenschaften aufweist:
\begin{lstlisting}
(define p (new Pokemon [name "Charmander"]
                       [size 'large]
                       [attr 'fire]))
 
> (send p who-are-you?)
\end{lstlisting}
{\routput {\qq}I am Charmander!\qq}
\begin{lstlisting}
> (send p hot?)
\end{lstlisting}
{\routput \#t}
\begin{lstlisting}
> (get-field size p)
\end{lstlisting}
{\rsymbol{large}}
\begin{lstlisting}
> (send (new Pokemon) who-are-you?)
\end{lstlisting}
{\routput {\qq}I am an Element!\qq}

Es fällt auf, dass kein Konflikt für \texttt{name} und \texttt{who-are-you?} auftritt. Das ist aber nicht weiter überraschend, denn wie wir wissen, passiert ja nur Einfachvererbung; das Feld \texttt{name} wird in der Vererbungshierarchie zweimal überschrieben, erst von Animal un dann von Element. Würden wir die Reihenfolge der Mixins vertauschen, so würden wir \texttt{{\qq}I am an Animal!\qq} as Ergebnis erhalten.

Falls uns die letzte Ausgabe stört, können wir auch für Pokemon den Default-Wert anpassen. Das geht leider nicht direkt in der Definition des Mixins, aber die Klasse Pokemon kann stattdessen von dem resultierenden Mixin erben:

\begin{lstlisting}
(define Pokemon (class (Element-Mixin (Animal-Mixin Thing))
                  (init [name "a Pokemon"])
                  (super-new [name name])))
     
> (send (new Pokemon) who-are-you?)
\end{lstlisting}
{\routput {\qq}I am a Pokemon!\qq}

Bisher wurden die geerbten Features von Thing einfach immer überschrieben. Wir wollen uns daher einmal anschauen, ob die Werte von Oberklassen von Pokemon auch kombiniert werden können. Nehmen wir dafür an, sowohl Element als auch Animal besitzen eine \texttt{attack}-Methode. Der Wert der \texttt{attack}-Methode für Pokemon soll sich aus beiden Oberklassen zusammensetzen als eine Liste aus Größe und Attribut.

\begin{lstlisting}
(define (Element-Mixin %) ...
     (define/public (attack) attr)))

(define (Animal-Mixin %) ...
     (define/public (attack) size)))
\end{lstlisting}

Wenn wir die Methode naiv beiden Mixins hinzufügen, so schlägt die Definition der Klasse Pokemon fehl:

{\rerror class*: superclass already contains method. method name: attack}

Racket erlaubt es nicht, dass zwei Methoden in einer Klasse den gleichen Namen haben. Element darf geerbte Methoden aus Animal nicht neu deklarieren. Falls wir vorhaben, sie zu überschreiben, so müssen wir \texttt{define/override} verwenden:

\begin{lstlisting}
(define (Element-Mixin %) ...
    (define/override (attack) attr))
\end{lstlisting}


Das führt jedoch dazu, dass wir nun bei der Erstellung der Element-Klasse nicht mehr Thing als Superklasse angeben können, denn die Klasse Thing bietet keine Funktion \texttt{attack}, die überschrieben werden könnte. Wollen wir also weiterhin, dass es möglich ist, sich Objekte von der Klasse Element zu erzeugen, so müssen wir eine Klasse bereitstellen, die eine solche Methode anbietet, damit Element von ihr erben kann.

\begin{lstlisting}
(define Element 
  (Element-Mixin (class object% (super-new)
                   (define/public (attack) null))))
\end{lstlisting}

Zudem ist der Angriff eines Pokemons nun ledligchlich der Wert des Feldes \texttt{attr}. 

Was wir eigentlich wollen, ist jedoch eine Kombination aus der Größe und dem Element. Das heißt, damit Pokemon das gewünschte Verhalten zeigt, müsste Element eine Kombination aus dem eigenen Wert und dem der Superklasse zurückgeben.

\begin{lstlisting}
(define (Element-Mixin %) ...
    (define/override (attack) (list (super attack) attr)))
\end{lstlisting}

Abgesehen davon, dass es kein sehr guter Programmierstil ist, die Logik der Klasse Pokemon in eine andere Klasse auszulagern, hat es wiederum Einfluss auf Objekte der Klasse Element. Anstatt des Attributs erhält man nun eine etwas seltsam anmutende Liste:

\begin{lstlisting}
> (send (new Element) attack)
\end{lstlisting}
{\rsymbol (() water)}

Dafür zeigt Pokemon nun das gewünschte Verhalten.
\begin{lstlisting}
> (send p attack)
\end{lstlisting}
{\rsymbol (large fire)}

Es ist jedoch nicht mehr möglich, die Reihenfolge der Mixins zu vertauschen. Eine Definition von Pokemon als

\begin{lstlisting}
(define Pokemon (Animal-Mixin (Element-Mixin Thing)))
\end{lstlisting}

führt zu einem Fehler, aus dem gleichen Grund wie vorher bei Objekten der Klasse Element: da Element eine Superklasse erwartet, die eine Funktion \texttt{attack} anbietet. Da Thing nun die direkte Superklasse ist, ist das nicht mehr der Fall. Selbst wenn wir das beheben würden, würde die Erzeugung nun an Animal scheitern, da es die geerbte Methode aus Element nicht überschreibt, sondern versucht neu zu definieren. Wir müssten alle Schritte, die wir soeben zur erfolgreichen Vererbung von der Methode \texttt{attack} durchgeführt haben, für den umgekehrten Fall definieren. 

Wollen wir beide Vererbungs-Reihenfolgen erlauben, wird zudem die Funktion \texttt{attack} deutlich komplizierter, da nun anhand der Superklasse entschieden werden müsste, ob der Wert des Feldes direkt zurückgegeben werden kann oder eine Kombination mit dem Wert der Superklasse nötig ist.

Wir haben bisher nur zwei Superklassen betrachtet. Bei drei, vier oder gar 20 Superklassen, die vielleicht selbst wiederum von mehreren Superklassen erben, wird, falls eine sinnvolle Modellierung von Methodenkombination mit Mixins überhaupt noch möglich ist, der Code extrem unübersichtlich und schwer wartbar. Insbesondere für die Lehre eignen sie sich demnach nicht.

\subsubsection{Traits}
Traits sind ähnlich zu Mixins. Sie kapseln eine Menge von Methoden, die zu einer Klasse hinzugefügt werden sollen. Traits erlauben jedoch Kontrolle darüber, welche Methoden wie geerbt werden. Es ist möglich bestimmte Methoden nicht zu erben, sie unter einem Alias zu erben oder mit Trait-Operatoren zu manipulieren und die Ergebnisse mehrerer Methoden zu kombinieren.

Sie lösen damit eines der fundamentalen Probleme von Mixins: Die Vererbung und Kombination gleichbenannter Methoden. Wenn es in zwei Traits, die kombiniert werden sollen, gleichbenannte Methoden gibt, so hat der Programmierer die Möglichkeit (und Pflicht), anzugeben, wie diese Kollision gelöst werden soll -- üblicherweise durch Ausschließen oder Umbenennen einer der Methoden in der Subklasse, oder durch Methodenkombination.

Die Definition von Traits ist syntaktisch oft fast identisch zu der Definition einer Klasse, es gibt nur zwei Unterschiede: Anstelle des Schlüssworts \texttt{class} wird \texttt{trait} benutzt und es müssen (und können) weder Superklasse noch Superkonstruktor-Aufruf angegeben werden. Traits unterstützen einen Großteil der Optionen, die auch \texttt{class} unterstützt, unter anderem aber weder \texttt{init} noch \texttt{init-field}. Das bedeutet, dass das ein Zugriff auf \texttt{name} nicht möglich ist (wir lassen den Code daher weg) und wir die Felder mit \texttt{field} definieren müssen.

\begin{lstlisting}
(require racket/trait)

(define Element-Trait
  (trait (field [attr 'water]) ; statt init-field
         (define/public (hot?) (equal? attr 'fire))
         (define/public (attack) attr)))

(define Animal-Trait
  (trait (field [size 'small])
         (define/public (attack) size)))
\end{lstlisting}

Wenn wir ein Pokemon-Trait aus diesen beiden Traits definieren wollen, müssen wir den Konflikt der beiden \texttt{attack}-Methoden beheben. Das geht jedoch im Gegensatz zu Mixins direkt im Pokemon-Trait. Zur Manipulation der Vererbung gibt verschiedene Trait-Operationen, wie
\begin{itemize}
 \item \texttt{trait-exclude}, das eine Methode von einem Trait entfernt,
 \item \texttt{trait-alias}, welches die Kopie einer Methode unter anderem Namen zum Trait hinzufügt und
 \item \texttt{trait-sum}, welche die Methoden von zwei Traits kombiniert.
\end{itemize}

Das Vorgehen bei einem Konflikt lässt sich generalisieren. Zunächst wird dafür gesorgt, dass es keinen Namenskonflikt mehr gibt. Dafür wird aus den zwei Traits mit kollidierender Methode jeweils ein neuer Trait erstellt, in dem diese Methode einen neuen, eindeutigen Namen erhält. Dafür würden wir beispielweise zum Trait Element mit \texttt{trait-alias} einen Alias für die \texttt{attack}-Methode hinzufügen, den wir \texttt{element-attack} nennen. Der Trait hat anschließend \emph{zwei} Funktionen für den Angriff, \texttt{attack} und \texttt{element-attack}, die beide das gleiche tun. Anschließend können wir mit \texttt{trait-exclude} die ursprüngliche \texttt{attack}-Methode von der Vererbung ausschließen. Es wird also nur die Alias-Methode \texttt{element-attack} vererbt.

Dieser Schritt wird für jeden Konflikt durchgeführt. Sobald alle Methoden einen eindeutigen Namen haben, können sie dann mit \texttt{trait-sum} kombiniert werden.

\begin{lstlisting}
 (define Pokemon-Trait
   (trait-sum   ; combine the following traits
    (trait-exclude (trait-alias Element-Trait   ; create an alias for
                                attack          ; attack and remove
                                element-attack) ; the original
                   attack)
    (trait-exclude (trait-alias Animal-Trait    ; same for animal
                                attack         
                                animal-attack)
                   attack)
    (trait (inherit element-attack animal-attack) ; combine the two
           (define/public (attack)                ; attack methods
             (list (animal-attack) (element-attack))))))
\end{lstlisting}

Wir erhalten einen neuen Trait. 

\begin{lstlisting}
> Pokemon-Trait
\end{lstlisting}
{\routput \#<trait>}

Man kann Traits nicht direkt zu Klassen hinzufügen, aber man kann sie mit der Funktion \texttt{trait->mixin} in ein Mixin umwandeln und dieses dann zu einer Klasse hinzufügen:

\begin{lstlisting}
 (define Pokemon-Mixin (trait->mixin Pokemon-Trait))
 (define Pokemon (Pokemon-Mixin Thing))
\end{lstlisting}

Da wir \texttt{field} statt \texttt{init-field} bei der Traitdefinition benutzt haben, ist es nun jedoch nicht mehr möglich, die Felder zu initialisieren. Falls wir das trotzdem wollen, müssen wir, wie zuvor bei dem Mixin, eine Subklasse erzeugen und alle Felder per Hand initialisieren:

\begin{lstlisting}
(define Pokemon (class (Pokemon-Mixin Thing)
                  ;; add initialization arguments by hand
                  (init [name "a Pokemon"]
                        [size 'small]
                        [attr 'water])
                  ;; name already is an init-field, we can just
                  ;; pass it to the super call
                  (super-new [name name])
                  ;; to have access to the others, we first need
                  ;; to inherit them
                  (inherit-field [super-size size] [super-attr attr])
                  ;; and then we can set them to the desired value
                  (set! super-size size)
                  (set! super-attr attr)))
\end{lstlisting}

Das gleiche Spiel muss analog für die Klassen Element und Animal durchgeführt werden, falls wir sie auch einzeln verwenden wollen. Wir können uns einmal vergewissern, dass Pokemon alle erwarteten Features hat:

\begin{lstlisting}
> (send (new Pokemon) who-are-you?)
\end{lstlisting}
{\routput {\qq}I am a Pokemon!\qq}

\begin{lstlisting}
(define p (make-object Pokemon "Charmander" 'large 'fire))
> (send p who-are-you?)
\end{lstlisting}
{\routput {\qq}I am Charmander!\qq}

\begin{lstlisting}
> (send p hot?)
\end{lstlisting}
{\routput \#t}

\begin{lstlisting}
> (send p attack)
\end{lstlisting}
{\rsymbol (large fire)}

Die Konfliktlösung bei Traits ist für einen ersten Einblick in Mehrfachvererbung recht umständlich und auch die Lösung für Initialisierungsparameter per Hand ist unschön. Zusätzlich sind Traits schlussendlich bessere Mixins und auch sie werden bei komplizierteren Vererbungshierarchien schnell unübersichtlich.

\subsection{Ergänzungsmethoden}

Es wurde bereits erwähnt, dass sich neue Methoden als öffentlich (\texttt{define/public}) oder privat (\texttt{define/private}) einführen lassen und geerbte Methoden aus der Superklasse mittels \texttt{define/override} überschrieben werden können. Wir wollen die Methodenarten, die Racket bietet, einmal genauer betrachten. 

Zusätzlich zum Überschreiben von Methoden bietet Racket auch die Möglichkeit, Methoden zu erzänzen. Die angegebene Klassenoption nach \texttt{define/} bestimmt, ob die definierte Methode eine geerbte Methode überschreibt oder ergänzt und auch, ob es möglich ist, diese Methode in einer Subklasse zu überschreiben oder zu ergänzen (Tabelle \ref{methods}).

\begin{table}[h]
 \centering \small
\begin{tabular}{|c'c|c|c|c|c}
 \hline
		& \multicolumn{1}{p{1.8cm}|}{\centering overrides method} 
		& \multicolumn{1}{p{1.8cm}|}{\centering augments method}
		& \multicolumn{1}{p{1.8cm}|}{\centering can be overridden}
		& \multicolumn{1}{p{1.8cm}|}{\centering can be augmented}
		\\ \thickhline
%                 & overrides & augments & can be     & can be    \\
%                 & method    & method   & overridden & augmented \\ \thickhline
 public         &           &          &     x      &           \\ \hline
 pubment        &           &          &            &    x      \\ \hline
 public-final   &           &          &            &           \\ \hline
 override       &     x     &          &     x      &           \\ \hline
 overment       &     x     &          &            &    x      \\ \hline
 override-final &     x     &          &            &           \\ \hline
 augride        &           &    x     &     x      &           \\ \hline
 augment        &           &    x     &            &    x      \\ \hline
 augment-final  &           &    x     &            &           \\ \hline
\end{tabular}
\caption{Methodenarten in Object Racket}
\label{methods}
\end{table}

Wird eine geerbte Methode mittels einer der drei \texttt{define/over*} Optionen überschrieben, so kann im Methodenrumpf mit \texttt{super} die Methode der Superklasse aufgerufen werden. Das erlaubt es, das Ergebnis der Supermethode weiter zu verwenden, zum Beispiel als Teil einer Berechnung:

\begin{lstlisting}
(define TheNumber (class object% (super-new)
                     (define/public (number)
                       (display "The number is ")
                       23)))

(define Sub (class TheNumber (super-new)
              (define/override (number)
                (display "Actually ")
                (+ (super number) 19))))

(send (new TheNumber) number)
\end{lstlisting}
{\routput The number is 23}
\begin{lstlisting}
(send (new Sub) number)
\end{lstlisting}
{\routput Actually The number is 42}

Um eine Methode zu ergänzen, muss sie in der Superklasse mit einer Methode des Schemas \texttt{define/*ment} definiert sein. Wir können sie dann mit einer Methode des Schemas \texttt{define/aug*} um Funktionalität ergänzen. Ergänzung erfolgt nach dem Prinzip von Schablonen- und Einschubmethode. Die Oberklasse gibt innerhalb der Methode durch einen Aufruf von \texttt{inner} an, an welcher Stelle die Methode der Subklasse aufgerufen werden soll (Schablonenmethode) und die erbende Klasse implementiert diese Methode (Einschubmethode):

\begin{lstlisting}
(define TheNumber (class object% (super-new)
                  (define/pubment (number)
                    (inner (void) number)
                    (display "The number is ")
                    23)))

(define Sub (class TheNumber (super-new)
                    (define/augment (number)
                      (display "Believe it! "))))
                      
> (send (new TheNumber) number)
\end{lstlisting}
{\routput The number is 23}

\begin{lstlisting}                
> (send (new Sub) number)
\end{lstlisting}
{\routput Believe it! The number is 23}

Das erste Argument von \texttt{inner} ist der Default-Wert. Er wird ausgewertet, wenn es keine ergänzende Methode gibt. In diesem Beispiel soll einfach gar nichts geschehen. Das zweite Argument ist der Name der ergänzenden Methode. Er muss mit dem Funktionsnamen übereinstimmen. Anschließend können noch Funktionsargumente übergeben werden. Der \texttt{inner}-Aufruf kann prinzipiell an einer beliebigen Stelle im Methodenrumpf stehen. Falls die Methode einen Wert zurückgibt, so muss dies aber natürlich nach dem letzten \texttt{inner}-Aufruf geschehen. Es ist auch möglich, mehrere \texttt{inner}-Aufrufe zu platzieren, dann wird die Methode der Subklasse mehrmals ausgeführt. 

Liefert die Sublasse einen Rückgabewert, so kann dieser weiter verwendet werden:

\begin{lstlisting}
(define TheNumber (class object% (super-new)
                     (define/pubment (number)
                       (display "The number is ")
                       (display (inner 23 number)))))

(define Sub (class TheNumber (super-new)
              (define/augment (number)
                42)))

> (send (new TheNumber) number)
\end{lstlisting}
{\routput The number is 23}

\begin{lstlisting}
> (send (new Sub) number)
\end{lstlisting}
{\routput The number is 42}

Durch \texttt{overment} ist eine Methode sogar in der Lage, gleichzeitig das Ergebnis der Superklasse und das Ergebnisse der Subklasse abzufragen und weiterzuverweneden. In einer größeren Vererbungshierarchie können dann lange Ketten von sich überschreibenden und ergänzenden Methoden entstehen. Je abwechslungreicher die verwendeten Methodenoptionen in einer Vererbungshierarchie sind, desto schwieriger kann es jedoch am Ende sein nachzuvollziehen, was die effektive Methode für ein Objekt der untersten Subklasse nun eigentlich in welcher Reihenfolge tut.

Wir haben gesehen, dass Object-Racket keine direkte Möglichkeit für Mehrfachvererbung bietet. Es gibt Mixins und Traits, doch beide werden intern auf Einfachvererbung abgebildet werden für kompliziertere Vererbungshierarchien schnell unübersichtlich. Dafür gibt es sehr umfangreiche Möglichkeiten, die Redefinition und Erweiterung von Methoden zu kontrollieren und alle  Methodenoptionen sind kompatibel mit Mixins und Traits. 

