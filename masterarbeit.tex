\input{chapters/header}
\pagestyle{diplHeadings}

\begin{document}

\include{chapters/titlepage}

\pagenumbering{Roman}
\setcounter{page}{1}
\pdfbookmark[1]{Inhaltsverzeichnis}{toc}
\tableofcontents
\cleardoublepage 

\pagenumbering{arabic}
\setcounter{page}{1} 
\mainmatter  
\setstretch{1.24}

\include{chapters/einleitung} 
\input{chapters/racket}
\input{chapters/objectracket} 
\include{chapters/clos}
\include{chapters/entwurf}
\include{chapters/analyse}


\chapter{Umsetzung}  
\label{implementation}
Im Rahmen dieser Arbeit ist ein Makro entstanden, das das \texttt{class}-Makro um Mehrfachvererbung und Methodenkombination erweitert. Das Makro nimmt die übergebene Syntax, hält wichtige Informationen in Form von Metaobjekten fest und generiert schließlich die Syntax, die vom eigentlichen \texttt{class}-Makro ausgewertet wird.

\section{eval}

Das erste Problem, das sich dabei stellt ist, dass Racket es nicht erlaubt, mehrere Superklassen anzugeben. Wir können zwar ein Makro schreiben, das mehrere Superklassen akzeptiert, aber der Makroaufruf, zu dem schlussendlich expandiert wird, darf nur eine Superklasse beinhalten. Das bedeutet, wir müssen aus den angegebenen Klassen selbst eine Superklasse erzeugen, die alle Eigenschaften der Klassen in sich vereinigt und diese als offizielle Superklasse angeben. Wie genau das funktioniert, sehen wir später, aber wir werden dafür die Klassenoptionen ebenjener Superklasse zusammenbauen, in einen \texttt{class}-Aufruf stecken und dann auswerten müssen.

Das Problem ist: \texttt{class} ist ein Makro, keine Funktion. Wir können es nicht einfach mit \texttt{apply} auf eine von uns zusammengestellte Liste von Klassenoptionen anwenden. Die andere naheliegende Option ist \texttt{eval}, welche jedoch nicht ohne weiteres außerhalb der Interaktionskonsole benutzt werden kann. Das Bereitstellen von \texttt{eval} auch innerhalb des Definitionsfensters geschieht noch vor der eigentlichen Expansion des Makros, deshalb soll auch hier zuerst darauf eingegangen werden.

\texttt{eval} ist eine Funktion in Racket, die einen quotierten Ausdruck nimmt und ihn auswertet. Salopp gesagt entfernt die Funktion einfach ein Quotierungszeichen (wenn es eins gibt):

\begin{lstlisting}
> (define x 42)
> 'x
\end{lstlisting}
{\rsymbol x}

\begin{lstlisting}
> (eval 'x)
\end{lstlisting}
{\routput 42}

Wir können damit insbesondere einen quotierten Funktionsaufruf auswerten:

\begin{lstlisting}
> (eval '(+ 1 2))
\end{lstlisting}
{\routput 3}

Aber \texttt{eval} funktioniert ohne weiteres nur in der Interaktionskonsole. Versuchen wir im Definitionsfenster den gleichen Ausdruck auszuwerten, so erhalten wir einen Fehler.

{\color{red}\ttfamily\small\hspace{5pt} +: unbound identifier;}\\
{\color{red}\ttfamily\small\hspace{5pt} also, no \#\%app syntax transformer is bound in: +}\\

\texttt{eval} kann die Bindungen des Kontextes, in dem es aufgerufen wird, nicht sehen. Das beinhaltet auch alle importierten Racket-Funktionen, selbst \texttt{+}. Damit \texttt{eval} Zugriff auf die Umgebung hat, in der es aufgerufen wird, muss man einen Namescpace mit übergeben. In der Interaktionskonsole passiert das automatisch; im Definitionsfenster müssen wir es per Hand machen. Dafür kann als zweiter Parameter ein Namespace-Wert übergeben werden. 

Die folgenden Definitionen und Beispiele sind dem Racket-Guide \cite{racketguide-namespace} entnommen.

Ein Namespace beinhaltet zwei Informationen:
\begin{enumerate}
 \item Eine Abbildung von Schlüsselwörtern zu Bindungen (zum Beispiel der Name \texttt{+} zu der Funktion \texttt{+}). Ein leerer Namespace bildet jeden Namen auf eine unintialisierte Variable ab.
 \item Eine Abbildung von Modulnamen zu Moduldeklarationen und Instanzen.
\end{enumerate}

Die erste Abbildung ist notwendig, zum Ausdrücke wie das Beispiel der Addition auszuwerten; die zweite für die Auwertung von \texttt{require}-Befehlen.

Ein leerer Namespace kann mit der Funktion \texttt{make-empty-namespace} erzeugt werden. Da der Namespace jedoch leer ist, passiert das gleiche wie als wenn wir keinen Namespace engegeben hätten: die Auswertung schlägt fehl. Um einen Namespace benutzbar zu machen, müssen Module aus dem aktuellen Namespace angehängt werden. \texttt{make-base-empty-namespace} erzeugt beispielsweise einen Namespace, an den das Modul \texttt{racket/base} bereits angehängt ist. Andere Module lassen sich mir \texttt{namespace-attach-module} anhängen:

\begin{lstlisting}
(namespace-attach-module (current-namespace)
                         'racket/class
                         (make-base-empty-namespace))
\end{lstlisting}

\texttt{current-namespace} liefert den aktuellen Namespace. Er beinhaltet alle Bindungen, die innerhalb des Kontextes, in dem die Funktion aufgerufen wird, vorhanden sind. Das \texttt{racket/class}-Modul aus dem aktuellen Namespace wird an den leeren Base-Namespace angehängt.

Das Anhängen eines Moduls bewirkt, dass innerhalb des Namespaces nun eine Abbildung des Modulnamen (Information 2) existiert; Mappings für die Funktionen und Schlüsselwörter existieren noch nicht. Wir haben dem Namespace lediglich mitgeteilt, wo das Modul zu finden ist. Für das Importieren gibt es die Funktion \texttt{parameterize}:

\begin{lstlisting}
(parameterize ([current-namespace (make-base-empty-namespace)])
  (namespace-require 'racket/class))
\end{lstlisting}

Module, die nicht dem Namespace angehängt sind, wie hier \texttt{racket/class}, werden neu geladen und instanziiert. Das bedeutet, dass für den Namespace ein neuer, eigenständiger \texttt{class}-Datentyp erzeugt wird:

\begin{lstlisting}
> (require racket/class)
> (class? object%)
\end{lstlisting}
{\routput \#t}

\begin{lstlisting}
> (class?
   (parameterize ([current-namespace (make-base-empty-namespace)])
     (namespace-require 'racket/class) ; loads again
     (eval 'object%)))
\end{lstlisting}
{\routput \#f}

Falls die gleiche Instanz des Datentyps benutzt werden soll, so muss das Modul zuerst an den Namespace angehängt werden:

\begin{lstlisting}
> (require racket/class)
> (class?
   (let ([ns (make-base-empty-namespace)])
     (namespace-attach-module (current-namespace)
                              'racket/class
                              ns)
     (parameterize ([current-namespace ns])
       (namespace-require 'racket/class) ; uses attached
       (eval 'object%))))
\end{lstlisting}
{\routput \#f}

Benötigt man den Namespace nur innerhalb eines Moduls, so kann man einen Namespace-Anchor definieren. Für das Benutzen von \texttt{eval} im Definitionsfenster können wir beispielsweise einfach schreiben:

\begin{lstlisting}
(define-namespace-anchor anchor)
(define ns (namespace-anchor->namespace anchor))
(define (my-eval x) (eval x ns))

> (my-eval '(+ 1 2))
\end{lstlisting}
{\routput 3}

Unser Modul definiert jedoch ein Makro, das in einem anderen Modul expandiert wird; und somit auch in einem anderen Namespace. Wenn wir auf diesen Namespace innerhalb unseres Moduls zugreifen wollen, so müssen wir die Funktion \texttt{my-eval} innerhalb der Makroexpansion definieren. Dafür wird die vorhergehende Methode mit \texttt{namespace-attach-module} und \texttt{parameterize} benutzt. Da wir später in der eigentlich Expansion drei Fälle unterscheiden wollen, passiert diese ``Zwischenexpansion'' in einem eigenen Makro:

\begin{lstlisting}
(define-syntax my-class
  (syntax-rules ()
    ; Match (my-class ...)
    [(my-class arg . args)
     ; Create a new namespace.
     (let ([ns (make-base-namespace)])
       ; Attach modules of the current namespace.
       (namespace-attach-module (current-namespace) 'racket/class ns)
       (namespace-attach-module (current-namespace) 'racket/list ns)
       (namespace-attach-module (current-namespace) 'racket/function ns)
       ; Import identifiert bindings from attached modules.
       (parameterize ([current-namespace ns])
         (namespace-require 'racket/class)
         (namespace-require 'racket/list)
         (namespace-require 'racket/function))
       ; Create an eval function that uses the namespace
       ; and add it to the syntax of the class call.
       ; Then expand the original class macro.
       (my-eval-class (lambda (x) (eval x ns)) arg . args))]))
\end{lstlisting}

Das Makro matcht Aufrufe von \texttt{my-class}. Wir erzeugen einen neuen Namespace, hängen die im Kontext des Makroaufrufes gebundenen Module \texttt{racket/class}, \texttt{racket/list} und \texttt{racket/function} an und binden sie anschließend ein. Der resultierende Namespace wird für die Definition einer \texttt{eval}-Funktion benutzt, die zu der Syntax des \texttt{my-class}-Aufrufes hinzugefügt wird. Anschließend wird das Makro \texttt{my-eval-class} aufgerufen, das die eigentliche Expansion übernimmt.

Der Name des Makros ist \texttt{my-class}, damit wir intern weiterhin Racket-Klassen mittels \texttt{class} erzeugen können. Wir benennen das Makro erst beim Export um:

\begin{lstlisting}
(provide (rename-out [my-class class]))
\end{lstlisting}

\section{Redefinition des class-Makros}
Im Makro \texttt{my-eval-class} geschieht die eigentliche Expansion des \texttt{class}-Makros. Es werden drei Fälle nach Syntax der Superklasse unterschieden:
\begin{itemize}
 \item eine einzelne Superklasse 
 \item die leere Liste \texttt{()} - wir interpretieren sie als \texttt{object\%}
 \item eine Liste von Superklassen \texttt{($<$superclass1$>$ $<$superclass2$>$ ...)}
\end{itemize}

Bei allen drei Optionen wird die Funktion \texttt{expand!} mit der \texttt{my-eval}-Funktion, der Liste der Superklassen und der Liste der restlichen Klassenoptionen aufgerufen:

\begin{lstlisting}
(define-syntax my-eval-class
  (syntax-rules ()
    [(my-eval-class my-eval () . rest) 
     (expand! my-eval (list object%) 'rest)]
    [(my-eval-class my-eval (super ...) . rest)
     (expand! my-eval (list super ...) 'rest)]
    [(my-eval-class my-eval super . rest)
     (expand! my-eval (list super) 'rest)]))
\end{lstlisting}

In \texttt{expand!} wird zu der Klassendefinition ein Metaobjeckt und ein Klassenobjekt erzeugt, die Klasse zur Liste der beobachteten Klassen hinzugefügt und anschließend das Klassenobjekt zurpckgegeben.

\begin{lstlisting}
(define (expand! my-eval supers args)
  (let* ([meta (ensure-class supers args)]                    ; meta object
         [obj  (make-classobject my-eval supers args meta)])  ; class object
    (add-class obj meta)
    obj))
\end{lstlisting}

Da Klassen in Racket keine Namen haben, wird das Objekt selbst als Schlüssel in der Klassenliste benutzt. \texttt{ensure-class} hat die gleiche Funktionalität wie in der CLOS-Implentierung. Sie hält alle wichtigen Informationen über das gerade zu erzeugende Objekt fest. 

\begin{lstlisting}
(define (ensure-class supers args)
  (let* ([direct-supers     (map find-class supers)]  
         [direct-fields     (compute-direct-fields args)]
         [direct-methods    (filter method-definition? args)]
         [generic-functions (filter generic-function-definition? args)]
         [meta (make-object meta-class% direct-supers direct-fields
                 direct-methods generic-functions)])
    (finalize-inheritance meta)
    (ensure-generic-functions meta)
    meta))
\end{lstlisting}


Das passiert in drei Schritten:
\begin{itemize}
 \item Es wird ein Metaobjekt mit den angegebenen Superklassen, Feldern, Methoden und generischen Funktionen erzeugt.
 \item \texttt{finalize-inheritance} fügt die Klassenpräzedentliste, geerbte Felder und Methoden hinzu.
 \item \texttt{ensure-generic-functions} aktualisiert die Liste der generischen Funktionen. Neue generische Funktionen, die in der aktuellen Klasse definiert werden, werden hinzugefügt und Methoden, zu denen eine generische Funktion existiert, werden zu der generischen Funktion hinzugefügt.
\end{itemize}

Das erzeugte Klassen-Metaobjekt wird anschließend zurückgegeben, denn wir müssen noch das tatsächliche Klassenobjekt erzeugen, bevor wir es zur Liste hinzufügen können. Die Erzeugung des Klassenobjekts betrachten wir zum Schluss. Zunächst soll auf die Implementierung der Metaklassen für Klassen und generische Funktionen näher eingegangen werden.

\section{Klassen-Metaobjekte}
Klassen-Metaobjekte werden analog zu CLOS definiert. Es gibt eine interne Racket-Klasse für Metaobjekte, hier \texttt{meta-class\%} genannt, die sich alle wichtigen Informationen über Superklassen, Felder und Methoden in Form von Feldern merkt.

Im Gegensatz zu CLOS manipulieren wir jedoch nur Syntax. Anstelle von Feld- und Methodenobjekten merkt sich die Metaklasse die Definitionen der Felder und Methoden. Sie werden erst ganz am Ende von Racket ausgewertet werden, als Teil der Definition des Klassenobjekts, das an den Nutzer zurückgegeben wird.

Für die Klasse Thing aus dem Object-Racket-Kapitel

\begin{lstlisting}
(define Thing (class object% (super-new)
                (init-field [name "a Thing"])
                (define/public (who-are-you?) 
                  (string-append "I am " name "!"))))
\end{lstlisting}

würden wir als direkte Felder die Liste 

\texttt{{\textquotesingle}((init-field [name {\qq}a Thing\qq]))} 

und als direkte Methoden die Liste 

\texttt{{\textquotesingle}((define/public (who-are-you?) (string-append {\qq}I am {\qq} name \qq!\qq)))} 

festhalten. Eine Ausnahme bilden die Superklassen. Klassen sind in Racket nicht benannt und der Benutzer hat die Freiheit die gleiche Klasse mehreren Variablen zuzuweisen. Um eine Klasse eindeutig identifiezieren zu können, brauchen wir also die Referenz; wir müssen die Superklassen auswerten. Um Klassen für Debugging unterscheiden zu können, weisen wir jeder Klasse außerdem eine aufsteigende Nummer zu. Die Anzahl der bisher erzeugten Klasse wird in der Variable \texttt{num-of-classes} festgehalten.

Da wir und später nicht für die eigentlichen Superklassen, sondern die zugehörigen Metaobjekte, interessieren, halten wir in der Klassenpräzedenzliste die Präzedenz der Metaklassen fest.

Im Gegensatz zu CLOS werden am Ende der Expansion von einer Klasse mit mehreren Superklassen zwei Klassen erstellt: Die Klasse, die die Eigenschaften der Superklassen zusammenfasst und die neue, durch das Makro definierte, Klasse, die von der zusammengestellten Superklasse erbt. Das bedeutet, dass wir am Ende unterscheiden zwischen geerbten Feldern und Methoden und solchen, die in der neuen Klasse definiert wurden. Es bietet sich daher an, anstelle der effektiven Felder und Methoden nur die geerbten festzuhalten. Die effektiven Eigenschaften lassen sich leicht in einer Methode als Vereinigung von direkten und geerbten ermitteln; umgekehrt müssten wir jedesmal die Liste der effektiven Eigenschaften filtern, um nur die geerbten zu erhalten. 

Es ergibt sich demnach die folgende Defintion für die Klassen-Metaklasse:

\begin{lstlisting}
(define meta-class%
  (class object% (super-new)
    (init-field direct-supers
                direct-fields
                direct-methods
                generic-functions)
    (field [number (begin 
                     (set! num-of-classes (+ 1 num-of-classes))
                     num-of-classes)]
           [class-precedence-list '()]
           [inherited-fields '()]
           [inherited-methods '()])    
    (define/public (effective-fields)
      (append direct-fields inherited-fields))
    (define/public (effective-methods)
      (append direct-methods inherited-methods))))
\end{lstlisting}

In einer Hashtabelle werden die bereits erzeugen Klassen als Paar (Klassenobjekt, Metaobjekt) festgehalten und es gibt die Methoden \texttt{findclass} und \texttt{add-class}, die den Zugriff erleichtern. Zu Beginn befindet sich bereits \texttt{object\%} und sein Metaobjekt in der Tabelle.

Die Superklassen, direkten Felder und Methoden lassen sich aus der Syntax der Klassendefinition extrahieren. Um Felder später unabhängig voneinander vererben zu können werden \texttt{field}- und \texttt{init-field}-Optionen, die mehr als ein Feld definieren gesplittet. Aus

\texttt{(field [a 1] [b 2])}

wird beispielsweise

\texttt{(field [a 1]) (field [b 2])}

Die Methode \texttt{compute-direct-fields} übernimmt diese Konversion.

Die Eigenschaften, die sich durch Verebung ergeben, werden durch die Methode \texttt{finalize-inheritance} zu einem Metaobjekt hinzugefügt. Sie berechnet die die Klassenpräzedentliste und anhand dieser die geerbten Felder und Methoden und bestückt die entprechenden Felder des Metaobjekts.

Für die Berechnung der Klassenpräzedentliste wird die CLOS-Methode \texttt{compute-std-cpl} verwendet. Sie erhält das Objekt, für das die Klassenpräzedentliste berechnet werden soll (wir verwenden das zugehörige Metaobjekt) sowie eine Methode, die zu einer (Meta-)Klasse die direkten Superklassen zurückgibt und liefert uns die vollständige Klassenpräzedentliste. Die Methode befindet sich in \texttt{tinyclos.rkt} im \texttt{swindle}-Paket, wird jedoch nicht exportiert. Der Quelltext wurde daher unverändert in unser Modul kopiert.


\chapter{Analyse/Erprobung/Auswertung/Test}
\textit{Das Kapitel bekommt noch einen sinnvollen Namen, sobald ich es geschrieben habe und weiß, was hier drinsteht. Wahrscheinlich ein Vergleich von Entwurf und Umsetzung und ein Fazit, wie gut sich das Metaobjekt-Protokoll eignet, um ein bestehendes Objektsystem zu erweitern sowie zwei Worte zur Effizienz (Zitat AMOP: ``Closette is simple, but it is woefully inefficient'').}

\begin{itemize}
 \item Test mit Pokemon-Beispiel
 \item Einschränkungen
 \item unterstützte Klassenoptionen
\end{itemize}


\chapter{Zusammenfassung und Ausblick}
\textit{Eine Zusammenfassung und eine Auflistung von Dingen, die aufbauend auf dieser Arbeit getan werden könnten.}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Literaturverzeichnis}
% compile by hand with bibtex masterarbeit.aux
\bibliographystyle{apalike}
\bibliography{chapters/bib}  
\cleardoublepage

\include{chapters/anhang}
\cleardoublepage

\include{chapters/erklaerung}

\end{document}
