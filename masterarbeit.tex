\input{chapters/header}
\pagestyle{diplHeadings}

\begin{document}

\include{chapters/titlepage}

\pagenumbering{Roman}
\setcounter{page}{1}
\pdfbookmark[1]{Inhaltsverzeichnis}{toc}
\tableofcontents
\cleardoublepage 

\pagenumbering{arabic}
\setcounter{page}{1} 
\mainmatter  
\setstretch{1.24}

\include{chapters/einleitung} 
\include{chapters/racket}
\input{chapters/objectracket} 
\input{chapters/clos}
\include{chapters/entwurf}

\chapter{CLOS: Hinter den Kulissen}
Um die Konzepte von CLOS auf ein anderes Objektsystem anwenden zu können, ist es hilfreich zu verstehen, wie CLOS funktioniert. Wir wollen deshalb einen Blick hinter die Kulissen werfen und die relevanten Konzepte der Implementation aufzeigen.

Makros sind das Sprachmittel, mit dem die Syntax einer Programmiersprache geschrieben und verändert wird. Der Einstiegspunkt einer jeden Erweiterung der Sprache ist ein Makro, das gilt sowohl für die Implementation von CLOS als auch die Erweiterung, die im Rahmen dieser Arbeit entstehen soll. Deshalb soll zunächst kurz auf die Grundlagen von Makros in Racket eingegangen werden. Dieser Teil basiert auf dem Guide ``Fear of Macros'' von Greg Hendershott \cite{fearofmacros} und dem Racket-Guide für Makros \cite{racketguide-macros}. %Die Code-Beispiele sind, falls nicht anders gekennzeichnet, dem ``Fear of Macros'' Guide entnommen.

Anschließend schauen wir uns an, wie CLOS implementiert ist. CLOS ist dabei nicht nur ein Ratgeber zur Implementation von Mehrfachvererbung. Es gibt uns außerdem einen Einblick, wie eine bestehende Sprache mithilfe von Makros und Metaobjekten um ein Objektsystem erweitert werden kann -- eine wichtige Grundlage für die Erweiterung von Racket. Die Implementationsdetails von CLOS sind dem Buch ``The Art of the Metaobject Protocol'' (AMOP) \cite{amop} entnommen. Die CLOS-Implementation in AMOP ist nicht in Racket, sondern Common Lisp und die Quelltextbeispiele wurden unverändert übernommen. Das sollte jedoch keinen erheblichen Einfluss auf die Verständlichkeit haben. Auf die Umsetzung in Racket wird im Kapitel \ref{implementation} näher eingegangen.

\input{chapters/makros}

\section{Grundstruktur von CLOS}
Es gibt drei Schlüsselwörter, die die Objektstruktur von CLOS definieren:  \texttt{defclass}, \texttt{defgeneric} und \texttt{defmethod}. Implementiert sind sie als Makros, die die interne Repräsentation der Klassen, generischen Funktionen und Methoden erzeugen und damit die Übersicht über die Informationen behalten, die in ihren Definitionen angegeben wurden.

Das \texttt{defclass}-Makro expandiert beispielsweise zu einem internen Methodenaufruf. Es werden die angegebenen Superklassen, Slots und anderen Optionen übergeben und die Methode sorgt dafür, dass eine interne Repräsentation dieser Klasse erstellt wird und anschließend das Klassenobjekt zurückgegeben wird.

Die Informationen werden in Form von Objekten festgehalten -- internen Objekten, die der Nutzer niemals zu sehen bekommt. Diese Objekte werden daher ``Metaobjekte'' genannt.

Es entsteht eine Struktur in drei Schichten:
\begin{itemize}
 \item die Makro-Expansions-Schicht: eine dünne Schicht, die die wenigen syntaktischen Konstrukte bereitstellt, die der Nutzer zu sehen bekommt, wie das \texttt{defclass}-Makro.
 \item Die ``Leim''-Schicht: hier werden die externen Namen auf die intern benutzten Metaobjekte abgebildet, zum Beispiel die Funktion \texttt{find-class}, welche ein Metaobjekt anhand des Namens heraussucht.
 \item Die Support-Schicht: Hier ist das Verhalten von Klassen, Instanzen, generischen Funktionen und Methoden implementiert. Das Metaobjekt-Protokoll konzentriert sich hauptsächlich auf diese Schicht.
\end{itemize}

Um diese Struktur zu verstehen, wollen wir in der untersten Schicht anfangen: bei den Metaobjekten.

\section{Metaobjekte}
CLOS ist zirkulär definiert: Der Code, der CLOS implementiert, ist in CLOS geschrieben. 

Natürlich ist die Sprachdefinition nicht wirklich rekursiv, sonst wäre jede Klassendefintion eine Endlosschleife. CLOS hat Wege gefunden, diese Zirkularität zu umgehen, über Bootstrapping und Reflection, aber das zu verstehen ist nicht Bestandteil dieser Arbeit. Wir werden später ebenfalls ein bereits fertig definiertes Objektsystem verwenden, um darauf aufbauend ein mächtigeres Objektsystem zu definieren: das Objektsystem von Racket.

Wichtig ist jedoch ist die Grundidee. Die Implementation von CLOS benutzt CLOS-Objekte.

Es gibt interne Objekte, die das Verhalten der dem Benutzer sichtbaren Klassen und Objekte definieren. Objekte über andere Objekte -- Metaobjekte. Es gibt solche Metaobjekte für alle Konstrukte, die für den Benutzer definiert werden sollen und über die daher Informationen gesammelt werden müssen: Klassenmetaobjekte für Klassen, Generische-Funktionen-Metaobjekte für generische Funktionen und Methodenmetaobjekte für Methoden. 

Wo es Objekte gibt, muss es auch eine Klasse geben, die ihr Verhalten definiert. Die Klasse, die das Verhalten von Metaobjekten definiert, wird Metaklasse genannt. 

Klassen-Metaobjekte sammeln beispielsweise all diejenigen Information, die zur Erstellung der aktuellen und zukünftiger Klassen relevant sind: den Namen der Klasse, die angegebenen Superklassen, definierte Slots, geerbte Slots, die Klassenpräzedenzliste, die direkten Subklassen und die definierten Methoden. 

Die ``Klassen-Metaklasse'' ist dann lediglich die Beschreibung, wie unsere Metaobjekte aussehen.

\begin{lstlisting}
(defclass standard-class ()
  (name :initarg :name
        :accessor class-name)
  (direct-superclasses :init-arg :direct-superclasses
                       :accessor class-direct-superclasses)
  (direct-slots :accessor class-direct-slots)
  (class-precedence-list :accessor class-precedence-list)
  (effective-slots :accessor class-slots)
  (direct-subclasses :initform ()
                     :accessor class-direct-subclasses)
  (direct-methods :initform ()
                  :accessor class-direct-methods))
\end{lstlisting}

Was sich zunächst ganz gruselig anhört, ist sehr einfach zu verstehen, wenn man CLOS lesen kann. Es ist eine ganz normale CLOS-Klasse, mit dem einzigen Unterschied, dass wir sie nur intern verwenden.

Die Aufgabe des \texttt{defclass}-Makros ist es nun, die Klassendefinition zu parsen und sie in einen Aufruf an die Methode \texttt{ensure-class} aus der ``Leim''-Schicht zu verwandeln. 

\begin{lstlisting}
(defmacro defclass (name direct-superclasses direct-slots &rest options)
  ´(ensure-class ',name
    :direct-superclasses ,(canonicalize-direct-superclasses 
                            direct-superclasses)
    :direct-slots ,(canonicalize-direct-slots direct-slots)
    ,@(canonicalize-defclass-options options)))
\end{lstlisting}

Der Makro-Befehl ist sehr ähnlich zu \texttt{define-syntaxrule}: das Pattern mit Name, Superklassen, Slots und anderen Optionen wird gematched und im anschließenden Template benutzt -- einem Aufruf der Methode ensure-class. Die \texttt{canonicalize}-Funktionen übernehmen die weitere Makro-Expansion, wie das Auswerten der Slot-Optionen, das Expandieren von Accessor-Optionen zu den Reader und Writer, Ersetzen der Namen der Superklassen durch die zugehören Metaobjekte und so weiter. Sie tun praktisch ``die ganze Arbeit'' der Expansion.

\texttt{ensure-class} nimmt dann den Namen und die Argumente der Klasse und definiert ein Klassenobjekt mit dem Namen:

\begin{lstlisting}
(defun ensure-class (name &rest all-keys)
  (if (find-class name nil)
      (error "Can't redefine the class named ~S.", name)
      (let ((class (apply #'make-instance
                          'standard-class :name name all-keys)))
        (setf (find-class name) class)
        class)))
\end{lstlisting}

Es werden die expandierten Klassenoptionen genommen und mit ihnen ein neues Metaobjekt erstellt. Das Metaobjekt wird zur Liste der bekannten Klassen hinzugefügt und anschließend zurückgegeben. 

Es gibt demnach eine Tabelle von Klassen-Metaobjekten, die bereits erstellt wurden, sowie Funktionen zum Abfragen, ob ein Objekt bereits existiert und zum Hinzufügen eines Objekts:

\begin{lstlisting}
(let ((class-table (make-hash-table :test #'eq)))
  
  (defun find-class (symbol &optional (errorp t))
    (let ((class (gethash symbol class-table nil)))
      (if (and (null class) errorp)
          (error "No class named ~S." symbol)
          class)))
  
  (defun (setf find-class) (new-value symbol)
    (setf (gethash symbol class-table) new-value))
)
\end{lstlisting}

\texttt{make-instance} ist eine Methode der untersten Schicht und führt noch einige notwendige Initialisierungen durch, wie das Hinzufügen des Objekts als Subklasse zu seinen Superklassen, Konvertieren der Liste von Sloteigenschaften in tatsächliche Slot-Definitionen oder die Definition von Accessor-Methoden. 

\section{Klassenpräzedenz}
Wir haben fast alle Schritte gesehen, die mit dem Erstellen eines Klassen-Metaobjekts zu tun haben: von \texttt{defclass} über \texttt{ensure-class} bis hin zu \texttt{make-instance}. Die verbleibenden Schritte haben mit Vererbung zu tun:
\begin{itemize}
 \item Berechnen und Speichern der Klassenpräzedenzliste
 \item Berechnen und Speichern der vollständigen Menge von Slots, bestehend aus direkt in der Klasse definierten und von Superklassen geerbten Slots.
\end{itemize}

Die Methode \texttt{finalize-inheritance}, die von \texttt{make-instance} aufgerufen wird führt beides aus:

\begin{lstlisting}
(defun finalize-inheritance (class)
  (setf (class-precedence-list class)
        (compute-class-precedence-list class))
  (setf (class-slots class)
        (compute-slots class))
  (values))
\end{lstlisting}

Die Klassenpräzedenzliste (nach \cite[S. 118ff]{keene}) beinhaltet die Klasse selbst und all ihre Superklassen, ohne Duplikate. Die Reihenfolge der Klassen ist dabei relevant; sie sind von der spezifischsten zur am wenigsten spezifischen Klasse geordnet. Wenn eine Klasse spezifischer als eine zweite Klasse ist, so hat sie Präzedenz über die zweite Klasse. Es gibt zwei Regeln, die die Reihenfolge von Klassen in der Präzedenzliste bestimmen:

\begin{enumerate}
 \item Eine Klasse hat immer Präzedenz über ihre Superklassen.
 \item Jede Klassendefinition legt die Präzedenzreihenfolge ihrer direkten Superklassen fest.
\end{enumerate}

Die erste Regel erlaubt es einer Klasse, Verhalten ihrer Superklasse zu überschreiben oder verändern.

Die zweite Regel bewirkt, dass die Reihenfolge direkter Superklassen durch die Reihenfolge der Superklassen im \texttt{defclass}-Makro festgelegt ist. Das heißt, jede angegebene Klasse ist spezifischer als die Klassen, die weiter hinten in der Liste stehen.

Anhand der ersten Regel kennen wir sofort die spezifischste und unspezifischste Klasse jeder Klassenpräzedenzliste. Die Klasse selbst ist die spezifischste und die Wurzelklasse, in Common Lisp \texttt{t} (und noch eine Ebene tiefer \texttt{standard-object}), die unspezifischste in jeder Klassenpräzedenzliste.

Wenn CLOS die Klassenpräzedenzliste einer Klasse bestimmt, startet es bei der Definition der Klasse. Es wendet beide Regeln auf die Klassendefinition an und erhält so eine Liste von Reihenfolgen-Constraints für die direkten Superklassen. Anschließend werden die Regeln auch auf jede direkte Superklasse angewendet, und so weiter, bis alle Pfade in der Wurzelklasse \texttt{t} enden. Das Ergebnis ist eine Menge von Reihenfolgen-Constraints aller beteiligten Klassen.

Der nächste Schritt ist es, eine Sortierung zu finden, die alle Einzelconstraints erfüllt. CLOS führt dazu eine topologische Sortierung durch: das Ermitteln einer Reihenfolge, in der alle Teil-Constraints erfüllt sind. Es entstehen drei Möglichkeiten:
\begin{enumerate}
 \item genau eine Reihenfolge erfüllt alle Constraints
 \item mehrere Reihenfolgen erfüllen alle Constraints
 \item keine Reihenfolge erfüllt alle Constraints
\end{enumerate}

In den ersten beiden Fällen erzeugt CLOS eine Klassenpräzedenzliste. Im dritten Fall wird ein Fehler signalisiert. Für das Pokemon-Beispiel (Abb. \ref{pokemon} ergibt sich beispielsweise die folgenden Constraints:

\begin{tabular}{l|c}
 \textbf{Constraint} & \textbf{Regel}\\ \hline
 \texttt{Pokemon $>$ Element} & 1\\
 \texttt{Pokemon $>$ Animal}  & 1\\
 \texttt{Element $>$ Animal}  & 2\\
 \texttt{Element $>$ Thing}   & 1\\
 \texttt{Animal  $>$ Thing}   & 1
\end{tabular}

Es gibt nur eine totale Ordnung, die alle Constraints erfüllt:

(\texttt{Pokemon Element Animal Thing standard-object t})

Oft ergeben die zwei Präzedenzregeln keine eindeutige Reihenfolge. Nehmen wir zum Beispiel an, Element und Animal haben keine gemeinsame Superklasse, sondern nur Element erbt von Thing und Animal von einer neuen Klasse Creature (Abb. \ref{creature}). 

\begin{figure}[h]
 \centering
 \includegraphics[scale=0.3]{pictures/creature}
 \caption{Vererbungshierarchie mit uneindeutiger Klassenpräzedenz.}
 \label{creature}
\end{figure}

Für Element und Creature sowie Thing und Creature gibt es dann nach den bisher bekannten Regeln kein Constraint, das eine Reihenfolge festlegt. Es ergeben sich drei mögliche Klassenpräzedenzlisten:

(\texttt{Pokemon Element Animal Creature Thing standard-object t})\\
(\texttt{Pokemon Element Animal Thing Creature standard-object t})\\ 
(\texttt{Pokemon Element Thing Animal Creature standard-object t})

CLOS entscheidet sich in dem Fall deterministisch für eine der möglichen Reihenfolgen: diejenige, in der Klassen aus einem Teilbaum möglichst nah beieinander sind. Wenn wir die Klassenhierarchie betrachten, so bilden Element und Thing einen Teilbaum, Animal und Creature einen anderen. CLOS würde demnach die dritte Möglichkeit bevorzugen, in der die Klassen direkt aufeinander folgen.

Falls die Reihenfolge der indirekten Superklassen für das Programm relevant ist, so ist es auch möglich dies als zusätzliches Constraint anzugeben. Nehmen wir beispielweise an, wir wollen, dass Creature in der Klassenpräzedenzliste vor Thing kommt. Wir können dieses Verhalten erzielen, indem wir die Klassen per Hand zu den ``direkten'' Superklassen in der Klassendefinition von Pokemon hinzufügen:

\begin{lstlisting}
(defclass Pokemon (Element Animal Creature Thing)
  ... )
\end{lstlisting}

Es werden dadurch zwei neue Constraints zur Liste hinzugefügt:

\begin{tabular}{l|c}
 \textbf{Constraint} & \textbf{Regel}\\
 \hline
 \texttt{Animal $>$ Creature} & 2\\
 \texttt{Creature $>$ Thing}  & 2\\
\end{tabular}

Diese zusätzlichen Regeln bewirken, dass es nun nur noch eine mögliche Klassenpräzedenzliste gibt:

(\texttt{Pokemon Element Animal Creature Thing standard-object t})\\

% Der Algorithmus in AMOP ist relativ umfangreich, da er sehr allgemein gehalten wurde. Die Vorgehensweise lässt sich jedoch als topologische Sortierung eines Baumes generalisieren: Die Klassen sind Knoten und die Superklassen die Kindknoten einer Klasse.
% \begin{itemize}
%  \item Finde alle Wurzelknoten ohne eingehende Kanten (= Klassen ohne Subklassen).
%  \begin{itemize}
%   \item Wenn es keine mehr gibt, brich ab und
%   \item wenn die Liste der noch zu bearbeitenden Knoten leer ist, dann ist die Klassenpräzedenzliste fertig
%   \item ansonsten ist der Graph inkonsistent und es gibt kein Ergebnis.
%  \end{itemize}
%  \item Wähle einen der Wurzelknoten.
%  \begin{itemize}
%   \item Falls es mehr als einen gibt: wähle den, dessen (ehemaliger) Vaterknoten am weitesten rechts in der bisherigen Klassenpräzedenzliste steht.
%  \end{itemize}
%  \item Entferne ihn aus der Liste noch zu betrachtender Knoten und füge ihn zur Klassenpräzedenzliste hinzu.
%  \item Wiederhole solange bis Abbruchkriterium erreicht.
% \end{itemize}




\section{Mehrfachvererbung und Methodenkombination}

\chapter{Implementation}  % überwiegend eigener Teil
\label{implementation}

\chapter{Analyse/Erprobung/Auswertung/Test}

\chapter{Zusammenfassung und Ausblick}

% -----------------------------------------------------------------------------------------
\include{chapters/literatur} 
\include{chapters/anhang}
\include{chapters/erklaerung}

\end{document}
