\input{chapters/header}
\pagestyle{diplHeadings}

\begin{document}

\include{chapters/titlepage}

\pagenumbering{Roman}
\setcounter{page}{1}
\pdfbookmark[1]{Inhaltsverzeichnis}{toc}
\tableofcontents
\cleardoublepage 

\pagenumbering{arabic}
\setcounter{page}{1} 
\mainmatter  
\setstretch{1.24}

\include{chapters/einleitung} % TODO ausformulieren
\include{chapters/racket}
\include{chapters/racket-onstage} % TODO Ergänzungsmethoden, Beispiele begründen
\include{chapters/clos-onstage}

\section{Zwischenfazit}
Das Objektsystem von Racket bietet zwar Mixins und Traits, beide sind jedoch geschickt verpackte Einfachvererbung und werden sehr schnell sehr kompliziert, wenn die Anzahl an Klassen steigt und gleichbenannte Methoden und Felder vorkommen. CLOS hingegen bietet einen sehr intuitiven Umgang mit Mehrfachvererbung. Es gibt generische Methoden, Methodenkombination und Ergänzungsmethoden.

Da der Umgang mit Mehrfachvererbung, wie CLOS ihn bietet, auch im Objektsystem von Racket umgesetzt werden soll, schauen wir nun hinter die Kulissen. Zunächst wird die Implementation von CLOS beleuchtet und im Anschluss die Implementation des Racket-Objektsystems.

\include{chapters/entwurf}

% -----------------------------------------------------------------------------------------

\chapter{Makros} 
\label{makros}
Um die Implementation einer Sprache zu verstehen, zu verändern oder zu erweitern ist es unumlässlich, sich mit Makros auseinanderzusetzen. 

Vorgehen... % TODO

Dieses Kapitel basiert auf dem Guide ``Fear of Macros'' von Greg Hendershott \cite{fearofmacros} und dem Racket-Guide für Makros \cite{racketguide-macros}. Die Code-Beispiele in ``Fear of Macros'' sind sehr anschaulich und wurden für diese Arbeit nahezu unverändert übernommen.


\section{Transformers}
\subsection{Was ist ein Syntaxtransformer?}

Ein Makro ist im Grunde eine Funktion. Sie erhält ein Stück Syntax als Eingabe und gibt ein anderes Stück Syntax zurück. Sie \textit{transformiert} Syntax. Wir können einen solchen Syntax-Transformer mit \texttt{define-syntax} definieren:

\begin{lstlisting}
(define-syntax foo
  (lambda (stx)
    (syntax "I am foo")))
\end{lstlisting}

Ein Aufruf von foo ergibt dann:

\begin{lstlisting}
> (foo)
\end{lstlisting}
{\routput {\qq}I am foo{\qq}}

Durch die Verwendung von \texttt{define-syntax} geschieht eine Transformer-Bindung. Wir teilen dem Racket-Compiler mit: ``Wann immer du im Quelltext ein Stück Syntax findest, das mit \texttt{foo} startet, gib es an meine Transformer-Funktion und ersetze es mit der Syntax, die ich dir zurück gebe.'' Racket gibt also alles, das aussieht wie \texttt{(foo ...)} an unsere Funktion und wir können neue Syntax zurückgeben, die stattdessen verwendet wird, ähnlich zu einer Suchen-und-Ersetzen-Operation.

\begin{lstlisting}
> (foo 1 2 3)
\end{lstlisting}
{\routput ``I am foo''}

Analog zu der Kurzschreibweise \texttt{(define (f x) ...)} anstelle von \texttt{(define (lambda (x) ...)} gibt es auch eine Kurzschreibweise für \texttt{define-syntax}:

\begin{lstlisting}
(define-syntax (also-foo stx)
  (syntax "I am also foo"))
  
> (also-foo)
\end{lstlisting}
{\routput ``I am also foo''}

Und auch für \texttt{syntax} gibt es die Abkürzung \texttt{\#\q} (analog zu \texttt{\q} und \texttt{quote}):

\begin{lstlisting}
(define-syntax (quoted-foo stx)
  #'"I am also foo, using #' instead of syntax")
  
> (also-foo)
\end{lstlisting}
{\routput {\qq}I am also foo, using \#\q instead of syntax{\qq}}

Obwohl sich die Funktion nun nicht mehr stark von einem \texttt{define} unterscheidet, ist es immer noch eine Transformer-Funktion, die Syntax entgegennimmt und Syntax zurückgibt.

\subsection{Syntax-Objekte}
Bisher haben wir die Eingabe-Syntax einfach ignoriert und eine festgelegte Syntax zurückgegen. Übsicherweise soll jedoch die Eingabe-Syntax transformiert werden. Wenn wir Syntax definieren, erhalten wir ein Syntax-Objekt:

\begin{lstlisting}
(define stx #'(+ 1 (* 2 3)))

> stx
\end{lstlisting}
{\routput\#<syntax:2:14 (+ 1 (* 2 3))>}

Ein Syntaxobjekt besteht aus einer Repräsentation des Ausdrucks, enthält aber auch Informationen über die Datei, Zeile und Spalte in der es definiert wurde sowie den Sichtbarkeitsbereich von Variablen (\emph{lexical scope}). All diese Informationen kann man mit entsprechenden Funktionen abfragen. Zwei dieser Funktionen, die auf Syntax arbeiten, sind \texttt{syntax->datum} und \texttt{syntax-e}. 

\texttt{syntax->datum} wandelt die Syntax in einen quotierten Racket-Ausdruck um:

\begin{lstlisting}
> (syntax->datum stx)
\end{lstlisting}
{\rsymbol (+ 1 (* 2 3))}

Analog lässt sich mit \texttt{datum->syntax} aus einem quotierten Racket-Ausdruck ein Syntax-Objekt erzeugen. Die Funktion benötigt zusätzlich zu der Syntax noch einen Kontext. Üblicherweise genügt es, als Kontext das ursprüngliche Syntaxobjekt anzugeben.

\texttt{syntax-e} geht nur ein Level tief. Es kann eine Liste von Syntax-Objekten zurückgeben:

\begin{lstlisting}
> (syntax-e lst)
\end{lstlisting}
{\rsymbol (\#<syntax:2:15 +> \#<syntax:2:17 1> \#<syntax:2:19 (* 2 3)>)}

Jedes dieser Syntax-Objekte kann dann rekursiv mit \texttt{sytax-e} weiter aufgelöst werden. Genau das macht \texttt{syntax->datum}.

Beim Transformieren von Syntax nehmen wir üblicherweise die Bestandteile der Syntax, die uns gegeben wird, ändern ihre Reihenfolge, ersetzen einige von ihnen oder führen gänzlich neue Bestandteile ein.

\subsection{Transformieren von Syntax}

Ein simples Beispiel, das die Reihenfolge der Syntax umkehrt:

\begin{lstlisting}
(define-syntax (reverse-me stx)
  (datum->syntax stx (reverse (cdr (syntax->datum stx)))))
  
> (reverse-me "backwards" "am" "I" values)
\end{lstlisting}
{\routput {\qq}I{\qq} {\qq}am{\qq} {\qq}backwards{\qq}}

Die Transformer-Funktion erhält die Syntax \texttt{\#\q(reverse-me {\qq}backwards{\qq} {\qq}am{\qq} {\qq}I{\qq} values)}. Zuerst wird diese durch \texttt{syntax->datum} in einen quotierten Ausdruck umgewandelt. Mit \texttt{cdr} entfernen wir das erste Element (reverse-me) aus der Liste, geben diese als Parameter als \texttt{reverse} und erhalten die Liste \texttt{\q(values {\qq}I{\qq} {\qq}am{\qq} {\qq}backwards{\qq})}. Durch Übergeben an die Funktion \texttt{datum->syntax} erhalten wir daraus ein Syntax-Objekt. Dieses Objekt wird von der Transformer-Funktion zurückgegeben und diese Syntax wird anschließend vom Compiler ausgewertet.

Der Syntax-Transformer wird zur Übersetzungszeit ausgewertet. Das bedeutet, dass die Teilstücke der Syntax zwar verschoben und ersetzt werden -- aber nicht ausgewertet. Das geschieht erst zur Laufzeit. Dadurch ermöglichen uns Makros beispielsweise die Definition eines eigenen \texttt{if} durch Benutzen von \texttt{cond}.

Würden wir \texttt{if} als normale Racket-Funtion definieren, so würden alle Parameter ausgewertet, bevor sie überhaupt an die Funktion gegeben werden. Das wird spätestens dann sichtbar, wenn sie Seiteneffekte beinhalten oder in einem Zweig der Fallunterscheidung ein rekursiver Aufruf steckt. Durch die Definition als Makro haben wir die Möglichkeit das \texttt{if} bereits zur Übersetzungszeit durch ein \texttt{cond} zu ersetzten:

\begin{lstlisting}
(define-syntax (my-if stx)
  (let ((xs (cdr (syntax->datum stx))))
    (datum->syntax stx `(cond [,(car xs) ,(cadr xs)]
                              [else ,(caddr xs)]))))
\end{lstlisting}

Durch das Quasiquote \texttt{`} werden nur die mit Komma markierten Teile der Liste ausgewertet.

Eine Liste immer mit \texttt{car}, \texttt{cadr} und so weiter zu zerlegen ist jedoch sehr anstrengend zu fehleranfällig. Eleganter geht es mithilfe von Pattern-Matching. Racket bietet dafür die Funktion \texttt{match}. 

Unsere Transformer-Funktion wird zur Übersetzungszeit ausgewertet. Zu diesem Zeitpunkt wird jedoch nur \texttt{racket/base} automatisch zur Verfügung gestellt, nicht das komplette \texttt{racket}. Alle Funktionen, die wir darüber hinaus benutzen wollen, müssen wir mit per Hand anfordern -- un zwar zur Übersetzungszeit. Dafür gibt es die \texttt{for-syntax}-Option von \texttt{require}:

\begin{lstlisting}
(require (for-syntax racket/match))

(define-syntax (my-if-using-match stx)
  (match (syntax-e stx)
    [(list name condition true-expr false-expr)
     (datum->syntax stx `(cond [,condition ,true-expr]
                               [else ,false-expr]))]))
\end{lstlisting}

\subsection{Hilfsfunktionen}
Wenn wir eine Hilfsfunktion für unser Makro benötigen, können wir sie nicht einfach mit \texttt{define} definieren und benutzen -- die Definition würde zur Laufzeit existieren, aber wir brauchen sie zur Übersetzungszeit. Eine Möglichkeit ist es, die Funktion in ein anderes Modul zu schreiben und dieses mit \texttt{for-syntax} einzubinden.

Falls wir die Funktion stattdessen im selben Modul definieren wollen, können wir sie innerhalb eines \texttt{begin-for-syntax}-Blocks definieren oder alternativ die Kurzform \texttt{define-for-syntax} benutzen:

\begin{lstlisting}
(begin-for-syntax
  (define (my-helper-function ...) 
    ...))
  
(define-for-syntax (my-helper-function ...)
  ...)
\end{lstlisting}

\section{Pattern Matching}
\subsection{define-syntax und syntax-case}
Das Makrosystem von Racket bietet eine noch bequemere Funktion für Pattern Matching: \texttt{syntax-case}.

Anstatt

\begin{lstlisting}
(require (for-syntax racket/match))
(define-syntax (my-if-using-match stx)
  (match (syntax-e stx)
    [(list name condition true-expr false-expr)
     (datum->syntax stx `(cond [,condition ,true-expr]
                               [else ,false-expr]))]))
\end{lstlisting}

können wir schreiben:

\begin{lstlisting}
(define-syntax (my-if-using-syntax-case stx)
  (syntax-case stx ()
    [(_ condition true-expr false-expr)
      #'(cond [condition true-expr]
             [else false-expr])]))
\end{lstlisting}

Das Quasiquote ist nicht mehr nötig und auch \texttt{datum->syntax} entfällt. Stattdessen stellen wir ein Template bereit, welches Variablen aus dem Pattern benutzt. 

\subsection{define-syntax-rule}

Auch für \texttt{syntax-case} gibt es eine Kurzform für einfache Pattern-Matching-Fälle namens \texttt{define-syntax-rule}:

\begin{lstlisting}
(define-syntax-rule 
  (my-if-using-syntax-rule condition true-expr false-expr) ; Pattern
  (cond [condition true-expr]                              ; Template
        [else false-expr]))
\end{lstlisting}

Diese Definition sieht so einfach aus, dass man denken könnte, es wäre eine normale Laufzeit-Funktion -- aber sie ist es nicht. Sie läuft zur Übersetzungszeit, nicht zur Laufzeit. 

\subsection{Sichtbarkeit von Variablen}

Sehr komfortable an dem Makro ist, dass es die Sichbarkeit von Variablen berücksichtigt. Nehmen wir beispielsweise das Makro, das zwei Werte vertauscht (nach \cite{racketguide-macros}):

\begin{lstlisting}
(define-syntax-rule (swap x y)
  (let ([tmp x])
    (set! x y)
    (set! y tmp)))
\end{lstlisting}

Angenommen, in der lokalen Umgebung des Makroaufrufs gibt es bereits eine Variable namens \texttt{tmp}:

\begin{lstlisting}
(let ([tmp 1]
      [other 2])
  (swap tmp other)
  (list tmp other))
\end{lstlisting}

Würden wir dahergehen und das Makro naiv expandieren, so würden die Werte nicht vertauscht werden:

\begin{lstlisting}
(let ([tmp 1]         ; tmp1
      [other 2])
  (let ([tmp tmp])    ; tmp2 verschattet tmp1
    (set! tmp other)  ; tmp2 = 2
    (set! other tmp)) ; other = tmp2 = 2
  (list tmp other))   ; (tmp1, other)
\end{lstlisting}

Tatsächlich produziert Racket jedoch nicht die naive Expansion. Sobald Variablen im lokalen Kontext des Makroaufrufs mit Makro-Variablen übereinstimmen, werden die Variablen im Makro vor der Expansion umbenannt. Wir erhalten also:

\begin{lstlisting}
(let ([tmp 1]
      [other 2])
  (let ([tmp_1 tmp])
    (set! tmp other)
    (set! other tmp_1))
  (list tmp other))
\end{lstlisting}

mit dem korrekten Ergebnis \texttt{(2,1)}.

\subsection{syntax-rules}
\texttt{define-syntax-rule} bindet ein Makro, das ein einzelnes Pattern abgleicht. Racket's Makro-System unterstützt mit \texttt{syntax-rules} jedoch auch Transformer für mehrere Patterns, die mit dem gleichen Bezeichner starten.

Beispielsweise könnten wir ein Makro definieren, das sowohl zwei als auch drei Werte miteinander vertauschen kann (nach \cite{racketguide-macros}):

\begin{lstlisting}
(define-syntax rotate
  (syntax-rules ()
    [(rotate a b) (swap a b)]
    [(rotate a b c) (begin
                     (swap a b)
                     (swap b c))]))
\end{lstlisting}

Es ist sogar möglich, Patterns beliebiger Länge in einem Makro zu matchen. Für eine beliebige Anzahl an Parametern können wir einfach \texttt{...} schreiben. Das Makro ähnelt dann einer rekursiven Funktion mit einem Standardfall (oder mehr) und einer Regel, wie mit dem Rest der Parameter zu verfahren ist (nach \cite{racketguide-macros}):

\begin{lstlisting}
(define-syntax rotate
  (syntax-rules ()
    [(rotate a) (void)]
    [(rotate a b c ...) (begin
                          (swap a b)
                          (rotate b c ...))]))
\end{lstlisting}

% \subsection{with-syntax}
% In einem Template können bisher nur Werte ersetzt werden, die vorher im Pattern bereits aufgetaucht sind. Oft wollen wir jedoch neue Teile definieren und benutzten. Das geht, indem \texttt{syntax-case} ineinander verschachtelt wird. Eine besser lesbare Kurzform für das Einführen einer neuen Pattern-Variable ist \texttt{with-syntax}. Es kann ähnlich wie ein \texttt{let} benutzt werden:

\section{Fehlerbehandlung}
Genau wie mit Standard-Funktionen gibt es auch bei Makros verschiedene Möglichkeiten mit einem fehlerhaftem Aufruf umzugehen: Ignorieren, Schreiben von fehlerbehandelndem Code oder \texttt{syntax-parse}. 

\texttt{syntax-parse} erlaubt es uns, das Eingabe-Pattern auf Richtigkeit zu prüfen, ähnlich zu einer Typprüfung oder einem Vertrag.

http://docs.racket-lang.org/syntax/stxparse.html %TODO

% -----------------------------------------------------------------------------------------

\chapter{CLOS: Backstage}
% \section{Das Objektsystem von Racket: Backstage}
\label{cpl}


\chapter{Implementation}  % überwiegend eigener Teil

\chapter{Analyse/Erprobung/Auswertung/Test}

\chapter{Zusammenfassung und Ausblick}

% -----------------------------------------------------------------------------------------

\include{chapters/anhang}
\include{chapters/literatur} % TODO
\include{chapters/erklaerung}

\end{document}
