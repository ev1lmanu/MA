\input{chapters/header}
\pagestyle{diplHeadings}

\begin{document}

\include{chapters/titlepage}

\pagenumbering{Roman}
\setcounter{page}{1}
\pdfbookmark[1]{Inhaltsverzeichnis}{toc}
\tableofcontents
\cleardoublepage 

\pagenumbering{arabic}
\setcounter{page}{1} 
\mainmatter  
\setstretch{1.24}

\include{chapters/einleitung} % TODO ausformulieren
\include{chapters/racket}
\include{chapters/objectracket} % TODO Ergänzungsmethoden, Beispiele begründen
\include{chapters/clos}

\section{Zwischenfazit}
Das Objektsystem von Racket bietet zwar Mixins und Traits, beide sind jedoch geschickt verpackte Einfachvererbung und werden sehr schnell sehr kompliziert, wenn die Anzahl an Klassen steigt und gleichbenannte Methoden und Felder vorkommen. CLOS hingegen bietet einen sehr intuitiven Umgang mit Mehrfachvererbung. Es gibt generische Methoden, Methodenkombination und Ergänzungsmethoden.

Da der Umgang mit Mehrfachvererbung, wie CLOS ihn bietet, auch im Objektsystem von Racket umgesetzt werden soll, schauen wir nun hinter die Kulissen. Zunächst wird die Implementation von CLOS beleuchtet und im Anschluss die Implementation des Racket-Objektsystems.

\include{chapters/entwurf}

% -----------------------------------------------------------------------------------------

\chapter{Makros} 
\label{makros}
Makros sind das Sprachmittel, mit dem die Syntax einer Programmiersprache geschrieben und verändert wird. Für diese Arbeit muss das \texttt{class}-Makro des Objektsystems Racket verändert werden, deshalb soll hier kurz auf die Grundlagen von Makros in Racket eingegangen werden.

Dieses Kapitel basiert auf dem Guide ``Fear of Macros'' von Greg Hendershott \cite{fearofmacros} und dem Racket-Guide für Makros \cite{racketguide-macros}. Die Code-Beispiele sind, falls nicht anders gekennzeichnet, dem ``Fear of Macros'' Guide entnommen.


\section{Transformers}
\subsection{Was ist ein Syntaxtransformer?}

Ein Makro ist im Grunde eine Funktion. Sie erhält ein Stück Syntax als Eingabe und gibt ein anderes Stück Syntax zurück. Sie \textit{transformiert} Syntax. Wir können einen solchen Syntax-Transformer mit \texttt{define-syntax} definieren:

\begin{lstlisting}
(define-syntax foo
  (lambda (stx)
    (syntax "I am foo")))
\end{lstlisting}

Ein Aufruf von foo ergibt dann:

\begin{lstlisting}
> (foo)
\end{lstlisting}
{\routput {\qq}I am foo{\qq}}

Durch die Verwendung von \texttt{define-syntax} geschieht eine Transformer-Bindung. Wir teilen dem Racket-Compiler mit: ``Wann immer du im Quelltext ein Stück Syntax findest, das mit \texttt{foo} startet, gib es an meine Transformer-Funktion und ersetze es mit der Syntax, die ich dir zurück gebe.'' Racket gibt also alles, das aussieht wie \texttt{(foo ...)} an unsere Funktion und wir können neue Syntax zurückgeben, die stattdessen verwendet wird, ähnlich zu einer Suchen-und-Ersetzen-Operation.

\begin{lstlisting}
> (foo 1 2 3)
\end{lstlisting}
{\routput ``I am foo''}

% Analog zu \texttt{define} und \texttt{quote} gibt es auch für \texttt{define-syntax} und \texttt{syntax} je eine Kurzschreibweise:

% \begin{lstlisting}
% (define-syntax (also-foo stx)
%   (syntax "I am also foo"))
%   
% > (also-foo)
% \end{lstlisting}
% {\routput ``I am also foo''}
% 
% Und auch für \texttt{syntax} gibt es die Abkürzung \texttt{\#\q} (analog zu \texttt{\q} und \texttt{quote}):

% \begin{lstlisting}
% (define-syntax (also-foo stx)
%   #'"I am also foo")
%   
% > (also-foo)
% \end{lstlisting}
% {\routput {\qq}I am also foo{\qq}}

% Obwohl sich die Funktion nun nicht mehr stark von einem \texttt{define} unterscheidet, ist es immer noch eine Transformer-Funktion, die Syntax entgegennimmt und Syntax zurückgibt.

\subsection{Syntax-Objekte}
Übsicherweise soll die Eingabe-Syntax transformiert werden. Wenn wir Syntax definieren, erhalten wir ein Syntax-Objekt:

\begin{lstlisting}
(syntax (+ 1 (* 2 3)))
\end{lstlisting}
{\routput\#<syntax:2:14 (+ 1 (* 2 3))>}

Ein Syntaxobjekt besteht aus einer Repräsentation des Ausdrucks, enthält aber auch Informationen über die Datei, Zeile und Spalte in der es definiert wurde sowie den Sichtbarkeitsbereich von Variablen (\emph{lexical scope}). All diese Informationen kann man mit entsprechenden Funktionen abfragen.% Zwei dieser Funktionen, die auf Syntax arbeiten, sind \texttt{syntax->datum} und \texttt{syntax-e}. 
% 
% \texttt{syntax->datum} wandelt die Syntax in einen quotierten Racket-Ausdruck um:
% 
% \begin{lstlisting}
% > (syntax->datum stx)
% \end{lstlisting}
% {\rsymbol (+ 1 (* 2 3))}
% 
% Analog lässt sich mit \texttt{datum->syntax} aus einem quotierten Racket-Ausdruck ein Syntax-Objekt erzeugen. Die Funktion benötigt zusätzlich zu der Syntax noch einen Kontext. Üblicherweise genügt es, als Kontext das ursprüngliche Syntaxobjekt anzugeben.
% 
% \texttt{syntax-e} geht nur ein Level tief. Es kann eine Liste von Syntax-Objekten zurückgeben:
% 
% \begin{lstlisting}
% > (syntax-e lst)
% \end{lstlisting}
% {\rsymbol (\#<syntax:2:15 +> \#<syntax:2:17 1> \#<syntax:2:19 (* 2 3)>)}
% 
% Jedes dieser Syntax-Objekte kann dann rekursiv mit \texttt{sytax-e} weiter aufgelöst werden. Genau das macht \texttt{syntax->datum}.

Beim Transformieren von Syntax nehmen wir üblicherweise die Bestandteile der Syntax, die uns gegeben wird, ändern ihre Reihenfolge, ersetzen einige von ihnen oder führen gänzlich neue Bestandteile ein.

Ein simples Beispiel, das die Reihenfolge der Syntax umkehrt:

\begin{lstlisting}
(define-syntax (reverse-me stx)
  (datum->syntax stx (reverse (cdr (syntax->datum stx)))))
  
> (reverse-me "backwards" "am" "I" values)
\end{lstlisting}
{\routput {\qq}I{\qq} {\qq}am{\qq} {\qq}backwards{\qq}}

Die Syntax

\begin{lstlisting}
#'(reverse-me "backwards" "am" "I" values)
\end{lstlisting}

(die Raute ist eine Kurzform für \texttt{syntax}) wird zunächst mit \texttt{syntax->datum} in den quotierten Ausdruck 

\begin{lstlisting}
'(reverse-me "backwards" "am" "I" values)
\end{lstlisting}


umgewandelt. Nachdem der Name der Funktion, \texttt{reverse-me}, abgeschnitten wurde, werden die Wörter mit \texttt{reverse} in umgekehrte Reihenfolge gebracht

\begin{lstlisting}
'(values "I" "am" "backwards")
\end{lstlisting}

und anschließend die Liste wieder in Syntax umgewandelt. Diese Syntax wird vom Compiler ausgewertet und ergibt schließlich die oben genannte Ausgabe.

% Die Transformer-Funktion erhält die Syntax \texttt{\#\q(reverse-me {\qq}backwards{\qq} {\qq}am{\qq} {\qq}I{\qq} values)}. Zuerst wird diese durch \texttt{syntax->datum} in einen quotierten Ausdruck umgewandelt. Mit \texttt{cdr} entfernen wir das erste Element (reverse-me) aus der Liste, geben diese als Parameter als \texttt{reverse} und erhalten die Liste \texttt{\q(values {\qq}I{\qq} {\qq}am{\qq} {\qq}backwards{\qq})}. Durch Übergeben an die Funktion \texttt{datum->syntax} erhalten wir daraus ein Syntax-Objekt. Dieses Objekt wird von der Transformer-Funktion zurückgegeben und diese Syntax wird anschließend vom Compiler ausgewertet.

Der Syntax-Transformer wird zur Übersetzungszeit ausgewertet. Das bedeutet, dass die Teilstücke der Syntax zwar verschoben und ersetzt werden -- aber nicht ausgewertet. Das geschieht erst zur Laufzeit. Dadurch ermöglichen uns Makros beispielsweise die Definition eines eigenen \texttt{if} durch Benutzen von \texttt{cond}.

Würden wir \texttt{if} als normale Racket-Funtion definieren, so würden alle Parameter ausgewertet, bevor sie überhaupt an die Funktion gegeben werden. Das wird spätestens dann sichtbar, wenn sie Seiteneffekte beinhalten oder in einem Zweig der Fallunterscheidung ein rekursiver Aufruf steckt. Durch die Definition als Makro haben wir die Möglichkeit das \texttt{if} bereits zur Übersetzungszeit durch ein \texttt{cond} zu ersetzten.

% \begin{lstlisting}
% (define-syntax (my-if stx)
%   (let ((xs (cdr (syntax->datum stx))))
%     (datum->syntax stx `(cond [,(car xs) ,(cadr xs)]
%                               [else ,(caddr xs)]))))
% \end{lstlisting}
% 
% Durch das Quasiquote \texttt{`} werden nur die mit Komma markierten Teile der Liste ausgewertet.

Eine Liste immer mit \texttt{car}, \texttt{cadr} und so weiter zu zerlegen ist jedoch sehr anstrengend und fehleranfällig. Eleganter geht es mithilfe von Pattern-Matching. %Racket bietet dafür die Funktion \texttt{match}. 

% Unsere Transformer-Funktion wird zur Übersetzungszeit ausgewertet. Zu diesem Zeitpunkt wird jedoch nur \texttt{racket/base} automatisch zur Verfügung gestellt, nicht das komplette \texttt{racket}. Alle Funktionen, die wir darüber hinaus benutzen wollen, müssen wir mit per Hand anfordern -- un zwar zur Übersetzungszeit. Dafür gibt es die \texttt{for-syntax}-Option von \texttt{require}:
% 
% \begin{lstlisting}
% (require (for-syntax racket/match))
% 
% (define-syntax (my-if-using-match stx)
%   (match (syntax-e stx)
%     [(list name condition true-expr false-expr)
%      (datum->syntax stx `(cond [,condition ,true-expr]
%                                [else ,false-expr]))]))
% \end{lstlisting}
% 
% \subsection{Hilfsfunktionen}
% Wenn wir eine Hilfsfunktion für unser Makro benötigen, können wir sie nicht einfach mit \texttt{define} definieren und benutzen -- die Definition würde zur Laufzeit existieren, aber wir brauchen sie zur Übersetzungszeit. Eine Möglichkeit ist es, die Funktion in ein anderes Modul zu schreiben und dieses mit \texttt{for-syntax} einzubinden.
% 
% Falls wir die Funktion stattdessen im selben Modul definieren wollen, können wir sie innerhalb eines \texttt{begin-for-syntax}-Blocks definieren oder alternativ die Kurzform \texttt{define-for-syntax} benutzen:
% 
% \begin{lstlisting}
% (begin-for-syntax
%   (define (my-helper-function ...) 
%     ...))
%   
% (define-for-syntax (my-helper-function ...)
%   ...)
% \end{lstlisting}

\section{Pattern Matching}
Das Makrosystem von Racket bietet eine sehr bequeme Funktion für Pattern Matching: \texttt{syntax-case} und dessen Kurzform \texttt{define-syntax-rule}. Anstatt die Syntax per Hand auseinanderzunehmen, stellen wir ein Template bereit, welches Variablen aus dem Pattern nutzt.

% Anstatt
% 
% \begin{lstlisting}
% (require (for-syntax racket/match))
% (define-syntax (my-if-using-match stx)
%   (match (syntax-e stx)
%     [(list name condition true-expr false-expr)
%      (datum->syntax stx `(cond [,condition ,true-expr]
%                                [else ,false-expr]))]))
% \end{lstlisting}

% \begin{lstlisting}
% (define-syntax (my-if-using-syntax-case stx)
%   (syntax-case stx ()
%     [(_ condition true-expr false-expr)
%       #'(cond [condition true-expr]
%              [else false-expr])]))
% \end{lstlisting}

 %Dadurch entfällt nicht nur die Hin- und Herwandlung mit \texttt{datum->syntax}, auch das Quasiquote ist in dem Fall nicht nötig:

% Auch für \texttt{syntax-case} gibt es eine Kurzform für einfache Pattern-Matching-Fälle namens \texttt{define-syntax-rule}:

\begin{lstlisting}
(define-syntax-rule 
  (my-if-using-syntax-rule condition true-expr false-expr) ; Pattern
  (cond [condition true-expr]                              ; Template
        [else false-expr]))
\end{lstlisting}

Diese Definition sieht so einfach aus, dass man denken könnte, es wäre eine normale Laufzeit-Funktion -- aber sie ist es nicht. Sie läuft zur Übersetzungszeit. 

% \subsection{Sichtbarkeit von Variablen}
% 
% Sehr komfortael an dem Makro ist, dass es die Sichbarkeit von Variablen berücksichtigt. Nehmen wir beispielsweise das Makro, das zwei Werte vertauscht (nach \cite{racketguide-macros}):
% 
% \begin{lstlisting}
% (define-syntax-rule (swap x y)
%   (let ([tmp x])
%     (set! x y)
%     (set! y tmp)))
% \end{lstlisting}
% 
% Angenommen, in der lokalen Umgebung des Makroaufrufs gibt es bereits eine Variable namens \texttt{tmp}:
% 
% \begin{lstlisting}
% (let ([tmp 1]
%       [other 2])
%   (swap tmp other)
%   (list tmp other))
% \end{lstlisting}
% 
% Würden wir dahergehen und das Makro naiv expandieren, so würden die Werte nicht vertauscht werden:
% 
% \begin{lstlisting}
% (let ([tmp 1]         ; tmp1
%       [other 2])
%   (let ([tmp tmp])    ; tmp2 verschattet tmp1
%     (set! tmp other)  ; tmp2 = 2
%     (set! other tmp)) ; other = tmp2 = 2
%   (list tmp other))   ; (tmp1, other)
% \end{lstlisting}
% 
% Tatsächlich produziert Racket jedoch nicht die naive Expansion. Sobald Variablen im lokalen Kontext des Makroaufrufs mit Makro-Variablen übereinstimmen, werden die Variablen im Makro vor der Expansion umbenannt. Wir erhalten also:
% 
% \begin{lstlisting}
% (let ([tmp 1]
%       [other 2])
%   (let ([tmp_1 tmp])
%     (set! tmp other)
%     (set! other tmp_1))
%   (list tmp other))
% \end{lstlisting}
% 
% mit dem korrekten Ergebnis \texttt{(2,1)}.

% \subsection{syntax-rules}
\texttt{define-syntax-rule} bindet ein Makro, das ein einzelnes Pattern abgleicht. Rackets Makro-System unterstützt mit \texttt{syntax-rules} jedoch auch Transformer für mehrere Patterns, die mit dem gleichen Bezeichner starten.

Beispielsweise könnten wir ein Makro definieren, das sowohl zwei als auch drei Werte miteinander vertauschen kann (nach \cite{racketguide-macros}):

\begin{lstlisting}
(define-syntax rotate
  (syntax-rules ()
    [(rotate a b) (swap a b)]
    [(rotate a b c) (begin
                     (swap a b)
                     (swap b c))]))
\end{lstlisting}

Es ist sogar möglich, Patterns beliebiger Länge in einem Makro zu matchen. Für eine beliebige Anzahl an Parametern gibt es die ``\texttt{...}``-Schreibweise. Das Makro ähnelt dann einer rekursiven Funktion mit einem Standardfall (oder mehr) und einer Regel, wie mit dem Rest der Parameter zu verfahren ist (nach \cite{racketguide-macros}):

\begin{lstlisting}
(define-syntax rotate
  (syntax-rules ()
    [(rotate a) (void)]
    [(rotate a b c ...) (begin
                          (swap a b)
                          (rotate b c ...))]))
\end{lstlisting}

% \subsection{with-syntax}
% In einem Template können bisher nur Werte ersetzt werden, die vorher im Pattern bereits aufgetaucht sind. Oft wollen wir jedoch neue Teile definieren und benutzten. Das geht, indem \texttt{syntax-case} ineinander verschachtelt wird. Eine besser lesbare Kurzform für das Einführen einer neuen Pattern-Variable ist \texttt{with-syntax}. Es kann ähnlich wie ein \texttt{let} benutzt werden:

% \section{Fehlerbehandlung}
% Genau wie mit Standard-Funktionen gibt es auch bei Makros verschiedene Möglichkeiten mit einem fehlerhaftem Aufruf umzugehen: Ignorieren, Schreiben von fehlerbehandelndem Code oder \texttt{syntax-parse}. 
% 
% \texttt{syntax-parse} erlaubt es uns, das Eingabe-Pattern auf Richtigkeit zu prüfen, ähnlich zu einer Typprüfung oder einem Vertrag.
% 
% http://docs.racket-lang.org/syntax/stxparse.html %TODO

% -----------------------------------------------------------------------------------------

% \chapter{CLOS: Backstage}
% % \section{Das Objektsystem von Racket: Backstage}
% \label{cpl}


\chapter{Implementation}  % überwiegend eigener Teil

\chapter{Analyse/Erprobung/Auswertung/Test}

\chapter{Zusammenfassung und Ausblick}

% -----------------------------------------------------------------------------------------

\include{chapters/anhang}
\include{chapters/literatur} % TODO
\include{chapters/erklaerung}

\end{document}
