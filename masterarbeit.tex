\input{chapters/header}
\pagestyle{diplHeadings}

\begin{document}

\include{chapters/titlepage}

\pagenumbering{Roman}
\setcounter{page}{1}
\pdfbookmark[1]{Inhaltsverzeichnis}{toc}
\tableofcontents
\cleardoublepage 

\pagenumbering{arabic}
\setcounter{page}{1} 
\mainmatter  
\setstretch{1.24}

\include{chapters/einleitung} 
\input{chapters/racket}
\input{chapters/objectracket} 
\include{chapters/clos}
\include{chapters/entwurf}
\include{chapters/analyse}


\chapter{Umsetzung}  
\label{implementation}
Im Rahmen dieser Arbeit ist ein Makro entstanden, das das \texttt{class}-Makro um Mehrfachvererbung und Methodenkombination erweitert. Das Makro nimmt die übergebene Syntax, hält wichtige Informationen in Form von Metaobjekten fest und generiert schließlich die Syntax, die vom eigentlichen \texttt{class}-Makro ausgewertet wird.

\section{eval}

Das erste Problem, das sich dabei stellt ist, dass Racket es nicht erlaubt, mehrere Superklassen anzugeben. Wir können zwar ein Makro schreiben, das mehrere Superklassen akzeptiert, aber der Makroaufruf, zu dem schlussendlich expandiert wird, darf nur eine Superklasse beinhalten. Das bedeutet, wir müssen aus den angegebenen Klassen selbst eine Superklasse erzeugen, die alle Eigenschaften der Klassen in sich vereinigt und diese als offizielle Superklasse angeben. Wie genau das funktioniert, sehen wir später, aber wir werden dafür die Klassenoptionen ebenjener Superklasse zusammenbauen, in einen \texttt{class}-Aufruf stecken und dann auswerten müssen.

Das Problem ist: \texttt{class} ist ein Makro, keine Funktion. Wir können es nicht einfach mit \texttt{apply} auf eine von uns zusammengestellte Liste von Klassenoptionen anwenden. Die andere naheliegende Option ist \texttt{eval}, welche jedoch nicht ohne weiteres außerhalb der Interaktionskonsole benutzt werden kann. Das Bereitstellen von \texttt{eval} auch innerhalb des Definitionsfensters geschieht noch vor der eigentlichen Expansion des Makros, deshalb soll auch hier zuerst darauf eingegangen werden.

\texttt{eval} ist eine Funktion in Racket, die einen quotierten Ausdruck nimmt und ihn auswertet. Salopp gesagt entfernt die Funktion einfach ein Quotierungszeichen (wenn es eins gibt):

\begin{lstlisting}
> (define x 42)
> 'x
\end{lstlisting}
{\rsymbol x}

\begin{lstlisting}
> (eval 'x)
\end{lstlisting}
{\routput 42}

Wir können damit insbesondere einen quotierten Funktionsaufruf auswerten:

\begin{lstlisting}
> (eval '(+ 1 2))
\end{lstlisting}
{\routput 3}

Aber \texttt{eval} funktioniert ohne weiteres nur in der Interaktionskonsole. Versuchen wir im Definitionsfenster den gleichen Ausdruck auszuwerten, so erhalten wir einen Fehler.

{\color{red}\ttfamily\small\hspace{5pt} +: unbound identifier;}\\
{\color{red}\ttfamily\small\hspace{5pt} also, no \#\%app syntax transformer is bound in: +}\\

\texttt{eval} kann die Bindungen des Kontextes, in dem es aufgerufen wird, nicht sehen. Das beinhaltet auch alle importierten Racket-Funktionen, selbst \texttt{+}. Damit \texttt{eval} Zugriff auf die Umgebung hat, in der es aufgerufen wird, muss man einen Namescpace mit übergeben. In der Interaktionskonsole passiert das automatisch; im Definitionsfenster müssen wir es per Hand machen. Dafür kann als zweiter Parameter ein Namespace-Wert übergeben werden. 

Die folgenden Definitionen und Beispiele sind dem Racket-Guide \cite{racketguide-namespace} entnommen.

Ein Namespace beinhaltet zwei Informationen:
\begin{enumerate}
 \item Eine Abbildung von Schlüsselwörtern zu Bindungen (zum Beispiel der Name \texttt{+} zu der Funktion \texttt{+}). Ein leerer Namespace bildet jeden Namen auf eine unintialisierte Variable ab.
 \item Eine Abbildung von Modulnamen zu Moduldeklarationen und Instanzen.
\end{enumerate}

Die erste Abbildung ist notwendig, zum Ausdrücke wie das Beispiel der Addition auszuwerten; die zweite für die Auwertung von \texttt{require}-Befehlen.

Ein leerer Namespace kann mit der Funktion \texttt{make-empty-namespace} erzeugt werden. Da der Namespace jedoch leer ist, passiert das gleiche wie als wenn wir keinen Namespace engegeben hätten: die Auswertung schlägt fehl. Um einen Namespace benutzbar zu machen, müssen Module aus dem aktuellen Namespace angehängt werden. \texttt{make-base-empty-namespace} erzeugt beispielsweise einen Namespace, an den das Modul \texttt{racket/base} bereits angehängt ist. Andere Module lassen sich mir \texttt{namespace-attach-module} anhängen:

\begin{lstlisting}
(namespace-attach-module (current-namespace)
                         'racket/class
                         (make-base-empty-namespace))
\end{lstlisting}

\texttt{current-namespace} liefert den aktuellen Namespace. Er beinhaltet alle Bindungen, die innerhalb des Kontextes, in dem die Funktion aufgerufen wird, vorhanden sind. Das \texttt{racket/class}-Modul aus dem aktuellen Namespace wird an den leeren Base-Namespace angehängt.

Das Anhängen eines Moduls bewirkt, dass innerhalb des Namespaces nun eine Abbildung des Modulnamen (Information 2) existiert; Mappings für die Funktionen und Schlüsselwörter existieren noch nicht. Wir haben dem Namespace lediglich mitgeteilt, wo das Modul zu finden ist. Für das Importieren gibt es die Funktion \texttt{parameterize}:

\begin{lstlisting}
(parameterize ([current-namespace (make-base-empty-namespace)])
  (namespace-require 'racket/class))
\end{lstlisting}

Module, die nicht dem Namespace angehängt sind, wie hier \texttt{racket/class}, werden neu geladen und instanziiert. Das bedeutet, dass für den Namespace ein neuer, eigenständiger \texttt{class}-Datentyp erzeugt wird:

\begin{lstlisting}
> (require racket/class)
> (class? object%)
\end{lstlisting}
{\routput \#t}

\begin{lstlisting}
> (class?
   (parameterize ([current-namespace (make-base-empty-namespace)])
     (namespace-require 'racket/class) ; loads again
     (eval 'object%)))
\end{lstlisting}
{\routput \#f}

Falls die gleiche Instanz des Datentyps benutzt werden soll, so muss das Modul zuerst an den Namespace angehängt werden:

\begin{lstlisting}
> (require racket/class)
> (class?
   (let ([ns (make-base-empty-namespace)])
     (namespace-attach-module (current-namespace)
                              'racket/class
                              ns)
     (parameterize ([current-namespace ns])
       (namespace-require 'racket/class) ; uses attached
       (eval 'object%))))
\end{lstlisting}
{\routput \#f}

Benötigt man den Namespace nur innerhalb eines Moduls, so kann man einen Namespace-Anchor definieren. Für das Benutzen von \texttt{eval} im Definitionsfenster können wir beispielsweise einfach schreiben:

\begin{lstlisting}
(define-namespace-anchor anchor)
(define ns (namespace-anchor->namespace anchor))
(define (my-eval x) (eval x ns))

> (my-eval '(+ 1 2))
\end{lstlisting}
{\routput 3}

Unser Modul definiert jedoch ein Makro, das in einem anderen Modul expandiert wird; und somit auch in einem anderen Namespace. Wenn wir auf diesen Namespace innerhalb unseres Moduls zugreifen wollen, so müssen wir die Funktion \texttt{my-eval} innerhalb der Makroexpansion definieren. Dafür wird die vorhergehende Methode mit \texttt{namespace-attach-module} und \texttt{parameterize} benutzt. Da wir später in der eigentlich Expansion drei Fälle unterscheiden wollen, passiert diese ``Zwischenexpansion'' in einem eigenen Makro:

\begin{lstlisting}
(define-syntax my-class
  (syntax-rules ()
    ; Match (my-class ...)
    [(my-class arg . args)
     ; Create a new namespace.
     (let ([ns (make-base-namespace)])
       ; Attach modules of the current namespace.
       (namespace-attach-module (current-namespace) 'racket/class ns)
       (namespace-attach-module (current-namespace) 'racket/list ns)
       (namespace-attach-module (current-namespace) 'racket/function ns)
       ; Import identifiert bindings from attached modules.
       (parameterize ([current-namespace ns])
         (namespace-require 'racket/class)
         (namespace-require 'racket/list)
         (namespace-require 'racket/function))
       ; Create an eval function that uses the namespace
       ; and add it to the syntax of the class call.
       ; Then expand the original class macro.
       (my-eval-class (lambda (x) (eval x ns)) arg . args))]))
\end{lstlisting}

Das Makro matcht Aufrufe von \texttt{my-class}. Wir erzeugen einen neuen Namespace, hängen die im Kontext des Makroaufrufes gebundenen Module \texttt{racket/class}, \texttt{racket/list} und \texttt{racket/function} an und binden sie anschließend ein. Der resultierende Namespace wird für die Definition einer \texttt{eval}-Funktion benutzt, die zu der Syntax des \texttt{my-class}-Aufrufes hinzugefügt wird. Anschließend wird das Makro \texttt{my-eval-class} aufgerufen, das die eigentliche Expansion übernimmt.

Der Name des Makros ist \texttt{my-class}, damit wir intern weiterhin Racket-Klassen mittels \texttt{class} erzeugen können. Wir benennen das Makro erst beim Export um:

\begin{lstlisting}
(provide (rename-out [my-class class]))
\end{lstlisting}

\section{Redefinition des class-Makros}
Im Makro \texttt{my-eval-class} geschieht die eigentliche Expansion des \texttt{class}-Makros. Es werden drei Fälle nach Syntax der Superklasse unterschieden:
\begin{itemize}
 \item eine einzelne Superklasse 
 \item die leere Liste \texttt{()} - wir interpretieren sie als \texttt{object\%}
 \item eine Liste von Superklassen \texttt{($<$superclass1$>$ $<$superclass2$>$ ...)}
\end{itemize}

Bei allen drei Optionen wird die Funktion \texttt{expand!} mit der \texttt{my-eval}-Funktion, der Liste der Superklassen und der Liste der restlichen Klassenoptionen aufgerufen:

\begin{lstlisting}
(define-syntax my-eval-class
  (syntax-rules ()
    [(my-eval-class my-eval () . rest) 
     (expand! my-eval (list object%) 'rest)]
    [(my-eval-class my-eval (super ...) . rest)
     (expand! my-eval (list super ...) 'rest)]
    [(my-eval-class my-eval super . rest)
     (expand! my-eval (list super) 'rest)]))
\end{lstlisting}

In \texttt{expand!} wird zu der Klassendefinition ein Metaobjeckt und ein Klassenobjekt erzeugt, die Klasse zur Liste der beobachteten Klassen hinzugefügt und anschließend das Klassenobjekt zurpckgegeben.

\begin{lstlisting}
(define (expand! my-eval supers args)
  (let* ([meta (ensure-class supers args)]                    ; meta object
         [obj  (make-classobject my-eval supers args meta)])  ; class object
    (add-class obj meta)
    obj))
\end{lstlisting}

Da Klassen in Racket keine Namen haben, wird das Objekt selbst als Schlüssel in der Klassenliste benutzt. \texttt{ensure-class} hat die gleiche Funktionalität wie in der CLOS-Implentierung. Sie hält alle wichtigen Informationen über das gerade zu erzeugende Objekt fest. 

\begin{lstlisting}
(define (ensure-class supers args)
  (let* ([direct-supers     (map find-class supers)]  
         [direct-fields     (compute-direct-fields args)]
         [direct-methods    (filter method-definition? args)]
         [generic-functions (filter generic-function-definition? args)]
         [meta (make-object meta-class% direct-supers direct-fields
                 direct-methods generic-functions)])
    (finalize-inheritance meta)
    (ensure-generic-functions meta)
    meta))
\end{lstlisting}


Das passiert in drei Schritten:
\begin{itemize}
 \item Es wird ein Metaobjekt mit den angegebenen Superklassen, Feldern, Methoden und generischen Funktionen erzeugt.
 \item \texttt{finalize-inheritance} fügt die Klassenpräzedentliste, geerbte Felder und Methoden hinzu.
 \item \texttt{ensure-generic-functions} aktualisiert die Liste der generischen Funktionen. Neue generische Funktionen, die in der aktuellen Klasse definiert werden, werden hinzugefügt und Methoden, zu denen eine generische Funktion existiert, werden zu der generischen Funktion hinzugefügt.
\end{itemize}

Das erzeugte Klassen-Metaobjekt wird anschließend zurückgegeben, denn wir müssen noch das tatsächliche Klassenobjekt erzeugen, bevor wir es zur Liste hinzufügen können. Die Erzeugung des Klassenobjekts betrachten wir zum Schluss. Zunächst soll auf die Implementierung der Metaklassen für Klassen und generische Funktionen näher eingegangen werden.

\section{Klassen-Metaobjekte}


\chapter{Analyse/Erprobung/Auswertung/Test}
\textit{Das Kapitel bekommt noch einen sinnvollen Namen, sobald ich es geschrieben habe und weiß, was hier drinsteht. Wahrscheinlich ein Vergleich von Entwurf und Umsetzung und ein Fazit, wie gut sich das Metaobjekt-Protokoll eignet, um ein bestehendes Objektsystem zu erweitern sowie zwei Worte zur Effizienz (Zitat AMOP: ``Closette is simple, but it is woefully inefficient'').}

\begin{itemize}
 \item Test mit Pokemon-Beispiel
 \item Einschränkungen
 \item unterstützte Klassenoptionen
\end{itemize}


\chapter{Zusammenfassung und Ausblick}
\textit{Eine Zusammenfassung und eine Auflistung von Dingen, die aufbauend auf dieser Arbeit getan werden könnten.}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Literaturverzeichnis}
% compile by hand with bibtex masterarbeit.aux
\bibliographystyle{apalike}
\bibliography{chapters/bib}  
\cleardoublepage

\include{chapters/anhang}
\cleardoublepage

\include{chapters/erklaerung}

\end{document}
